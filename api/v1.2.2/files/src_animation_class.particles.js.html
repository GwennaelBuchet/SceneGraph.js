<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\animation\class.particles.js - cgSceneGraph</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/__GLOBAL_CONSTANTS__.html">__GLOBAL_CONSTANTS__</a></li>
            
                <li><a href="..&#x2F;classes/__GLOBAL_METHODS__.html">__GLOBAL_METHODS__</a></li>
            
                <li><a href="..&#x2F;classes/__GLOBAL_PROPERTIES__.html">__GLOBAL_PROPERTIES__</a></li>
            
                <li><a href="..&#x2F;classes/__UTIL_ARRAY__.html">__UTIL_ARRAY__</a></li>
            
                <li><a href="..&#x2F;classes/CGSGAnimationKey.html">CGSGAnimationKey</a></li>
            
                <li><a href="..&#x2F;classes/CGSGButtonMode.html">CGSGButtonMode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGColor.html">CGSGColor</a></li>
            
                <li><a href="..&#x2F;classes/CGSGDimension.html">CGSGDimension</a></li>
            
                <li><a href="..&#x2F;classes/CGSGHandleBox.html">CGSGHandleBox</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMath.html">CGSGMath</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNode.html">CGSGNode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeButton.html">CGSGNodeButton</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeCircle.html">CGSGNodeCircle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeEllipse.html">CGSGNodeEllipse</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeImage.html">CGSGNodeImage</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSprite.html">CGSGNodeSprite</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSquare.html">CGSGNodeSquare</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeText.html">CGSGNodeText</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeWebview.html">CGSGNodeWebview</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticle.html">CGSGParticle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleEmitter.html">CGSGParticleEmitter</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleSystem.html">CGSGParticleSystem</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPickNodeMethod.html">CGSGPickNodeMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPosition.html">CGSGPosition</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRegion.html">CGSGRegion</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRotation.html">CGSGRotation</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScale.html">CGSGScale</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScene.html">CGSGScene</a></li>
            
                <li><a href="..&#x2F;classes/CGSGSceneGraph.html">CGSGSceneGraph</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTimeline.html">CGSGTimeline</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTraverser.html">CGSGTraverser</a></li>
            
                <li><a href="..&#x2F;classes/CGSGVector2D.html">CGSGVector2D</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWEBVIEWMODE.html">CGSGWEBVIEWMODE</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWrapMode.html">CGSGWrapMode</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Animation.html">Animation</a></li>
            
                <li><a href="..&#x2F;modules/Math.html">Math</a></li>
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="..&#x2F;modules/Scene.html">Scene</a></li>
            
                <li><a href="..&#x2F;modules/Util.html">Util</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\animation\class.particles.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2012  Capgemini Technology Services (hereinafter “Capgemini”)
 *
 * License&#x2F;Terms of Use
 *
 * Permission is hereby granted, free of charge and for the term of intellectual property rights on the Software, to any
 * person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to use, copy, modify
 * and propagate free of charge, anywhere in the world, all or part of the Software subject to the following mandatory
 * conditions:
 *
 *   •    The above copyright notice and this permission notice shall be included in all copies or substantial portions
 *   of the Software.
 *
 *  Any failure to comply with the above shall automatically terminate the license and be construed as a breach of these
 *  Terms of Use causing significant harm to Capgemini.
 *
 *  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 *  Except as contained in this notice, the name of Capgemini shall not be used in advertising or otherwise to promote
 *  the use or other dealings in this Software without prior written authorization from Capgemini.
 *
 *  These Terms of Use are subject to French law.
 *&#x2F;

&quot;use strict&quot;;

&#x2F;**
 * @module Animation
 * @submodule ParticleSystem
 * @class CGSGParticle
 * @constructor
 * @param node {CGSGNode}
 * @type {CGSGParticle}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGParticle = CGSGObject.extend(
	{
		initialize : function (node) {
			&#x2F;**
			 * @property node
			 * @type {CGSGNode}
			 *&#x2F;
			this.node = node;

			this.node.isClickable = false;
			this.node.isResizable = false;
			this.node.isDraggable = false;

			&#x2F;**
			 * A void* property to let the developer store whatever he needs (new properties, ...)
			 * @property userdata
			 * @type {*}
			 * @default null
			 *&#x2F;
			this.userdata = null;

			this.init();
		},

		&#x2F;**
		 * Initialize attributes of this particle
		 * @public
		 * @method init
		 *&#x2F;
		init : function () {
			&#x2F;&#x2F;this.direction = new CGSGVector2D(1, 0);
			this.position = new CGSGPosition(0.0, 0.0);
			this.mass = 1000;
			this.initVelocity(new CGSGVector2D(1.0, 1.0));
			this.checkCTL = null;
			this.isAlive = true;
			this.age = 0;

			&#x2F;&#x2F;this._gravity = new CGSGVector2D(0.0, 0.0);
			&#x2F;&#x2F;this._forceTotal = new CGSGVector2D(0.0, 0.0);
			this._acceleration = new CGSGVector2D(0.0, 0.0);

			this.speedThreshold = 0.0;
		},

		&#x2F;**
		 * @public
		 * @method initPosition
		 * @param {Number} x
		 * @param {Number} y
		 *&#x2F;
		initPosition : function (x, y) {
			this.position.x = x;
			this.position.y = y;
			this.node.translateTo(x, y);
		},

		&#x2F;**
		 * @public
		 * @method initVelocity
		 * @param {CGSGVector2D} velocity
		 *&#x2F;
		initVelocity : function (velocity) {
			this.velocity = velocity.copy();
			this.velocity.normalize();
		},

		&#x2F;**
		 * @public
		 * @method initSpeedThreshold
		 * @param {Number} st
		 *&#x2F;
		initSpeedThreshold : function (st) {
			this.speedThreshold = st;
		},

		&#x2F;**
		 * update the particle position with an Euler integration
		 * TODO : externalize the process to choose between RK4 and Euler integration
		 * @public
		 * @method updatePosition
		 * @param {Number} deltaTime
		 * @param {Number} acceleration
		 * @return {*}
		 *&#x2F;
		updatePosition : function (deltaTime, acceleration) {
			if (isNaN(deltaTime)) {
				deltaTime = 1.0;
			}

			deltaTime += this.speedThreshold;

			this._acceleration.x = acceleration.x &#x2F; this.mass;
			this._acceleration.y = acceleration.y &#x2F; this.mass;

			this.velocity.x += this._acceleration.x * deltaTime;
			this.velocity.y += this._acceleration.y * deltaTime;

			this.position.x += this.velocity.x * deltaTime;
			this.position.y += this.velocity.y * deltaTime;

			if (this.node !== null) {
				this.node.translateTo(this.position.x, this.position.y);
			}

			&#x2F;&#x2F;increment age of the particle
			this.age += deltaTime;

			&#x2F;&#x2F;check the viablity of the particle
			if (cgsgExist(this.checkCTL)) {
				this.isAlive = this.checkCTL(this);
			}
			return this.isAlive;
		}
	}
);

&#x2F;**
 * A particle emitter for the cgSceneGraph Particle System
 * @class CGSGParticleEmitter
 * @extends {CGSGNode}
 * @module Animation
 * @submodule ParticleSystem
 * @constructor
 * @param {CGSGNode} node
 * @param {CGSGRegion} region
 * @param {Number} nbParticlesMax
 * @param {Number} velocity
 * @param {Number} angle
 * @param {Number} speed
 * @param {Number} speedThreshold
 * @param {Number} outflow
 * @type {CGSGParticleEmitter}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGParticleEmitter = CGSGNode.extend(
	{
		initialize : function (node, region, nbParticlesMax, velocity, angle, speed, speedThreshold, outflow) {
			this._super(region.position.x, region.position.y, region.dimension.width, region.dimension.height);

			&#x2F;**
			 * @property classType
			 * @type {String}
			 *&#x2F;
			this.classType = &quot;CGSGParticleEmitter&quot;;

			this._node = node;
			&#x2F;**
			 * the region from where the particles are emitted
			 * @property region
			 * @type {CGSGRegion}
			 *&#x2F;
			this.region = region;
			&#x2F;**
			 * number max of particles out of the emitter on 1 frame
			 * @property nbParticlesMax
			 * @type {Number}
			 *&#x2F;
			this.nbParticlesMax = nbParticlesMax;
			&#x2F;**
			 * @property velocity
			 * @type {CGSGVector2D}
			 *&#x2F;
			this.velocity = new CGSGVector2D(0.0, 0.0);
			if (cgsgExist(velocity)) {
				this.velocity = velocity;
			}
			&#x2F;**
			 * angle range of emission. a particle is emitted in the this.direction vector + or - this.angle&#x2F;2 angle.
			 * @property angle
			 * @type {Number}
			 *&#x2F;
			this.angle = Math.PI &#x2F; 5.0;
			if (cgsgExist(angle)) {
				this.angle = angle;
			}

			&#x2F;**
			 * speed of a particle
			 * @property speed
			 * @type {Number}
			 *&#x2F;
			this.speed = 1.0;
			if (cgsgExist(speed)) {
				this.speed = speed;
			}
			&#x2F;**
			 * threshold to randomize and add to the speed of a particle
			 * @property speedThreshold
			 * @type {Number}
			 *&#x2F;
			this.speedThreshold = 1.0;
			if (cgsgExist(speedThreshold)) {
				this.speedThreshold = speedThreshold;
			}

			&#x2F;**
			 * @property outflow
			 * @type {Number}
			 *&#x2F;
			this.outflow = 0;
			if (cgsgExist(outflow)) {
				this.outflow = outflow;
			}

			this._currentFrame = this.outflow;

			&#x2F;&#x2F;list of the particles
			this._particles = [];
			this._isPlaying = false;
			this._forces = [];
			this._acceleration = new CGSGVector2D(0.0, 0.0);

			&#x2F;**
			 * Gravity Force added by default with the addForce method
			 * @property gravity
			 * @type {Object}
			 *&#x2F;
			this.gravity = this.addForce(new CGSGVector2D(0.0, 9.81), null);

			&#x2F;**
			 * Callback on end of update for 1 particle
			 * @property onUpdateParticleEnd
			 * @default null
			 * @type {function}
			 *&#x2F;
			this.onUpdateParticleEnd = null;
			&#x2F;**
			 * Callback when reinit for 1 particle
			 * @property onInitParticle
			 * @default null
			 * @type {function}
			 *&#x2F;
			this.onInitParticle = null;
			&#x2F;**
			 * Callback when reinit all particles is done
			 * @property onInitParticlesEnd
			 * @default null
			 * @type {function}
			 *&#x2F;
			this.onInitParticlesEnd = null;
		},

		&#x2F;**
		 * start the animation
		 * @public
		 * @method start
		 *&#x2F;
		start : function () {
			this._isPlaying = true;
		},

		&#x2F;**
		 * stop the animation
		 * @public
		 * @method stop
		 *&#x2F;
		stop : function () {
			this._isPlaying = false;
		},

		&#x2F;**
		 * reset the animation
		 * @public
		 * @method reset
		 *&#x2F;
		reset : function () {
			var p;
			this._currentFrame = 0;
			&#x2F;&#x2F;free the memory
			for (p = this._particles.length - 1; p &gt;= 0; p--) {
				this.removeChild(this._particles[p].node);
				delete (this._particles[p]);
			}
			this._particles.clear();

			&#x2F;&#x2F;this.initParticles(this._node);
		},

		&#x2F;**
		 * @override
		 * @public
		 * @method render
		 * @param context
		 *&#x2F;
		render : function (context) {
			var f, p;
			this.beforeRender(context);

			&#x2F;&#x2F;update the acceleration of the particles, based on the current forces
			this._acceleration.initialize(0.0, 0.0);
			for (f = this._forces.length - 1; f &gt;= 0; f--) {
				this._acceleration.x += this._forces[f].vector.x;
				this._acceleration.y += this._forces[f].vector.y;

				if (this._forces[f].ctl !== null) {
					this._forces[f].age++;
					if (this._forces[f].age &gt;= this._forces[f].ctl) {
						this.removeForce(this._forces[f]);
					}
				}
			}

			&#x2F;&#x2F;updates all particles
			for (p = 0; p &lt; this._particles.length; p++) {
				if (this._isPlaying) {
					if (!this.updateParticle(this._particles[p])) {
						this.initParticle(this._particles[p], p);
					}
				}

				this._particles[p].node.render(context);
			}

			&#x2F;&#x2F;if not all of the particles are out
			if (this._particles.length &lt; this.nbParticlesMax) {
				this._currentFrame++;
				if (this._currentFrame &gt;= this.outflow) {
					this._currentFrame = 0;
					this._createParticle(this._particles.length);
				}
			}

			&#x2F;&#x2F;restore state
			&#x2F;&#x2F;this.afterRender(context);
			context.restore();
		},

		&#x2F;**
		 * create a new particle, and add it to the emitter
		 * @private
		 * @method _createParticle
		 * @param {Number} index
		 *&#x2F;
		_createParticle : function (index) {
			var particle = new CGSGParticle(this._node.copy());
			this.initParticle(particle, index);
			this.addChild(particle.node);
			this._particles.push(particle);
		},

		&#x2F;**
		 * @public
		 * @method updateParticle
		 * @param {CGSGParticle} particle
		 * @return {Boolean}
		 *&#x2F;
		updateParticle : function (particle) {
			&#x2F;&#x2F;first, update the position of the particle node
			var isAlive = particle.updatePosition(this.speed, this._acceleration);

			&#x2F;&#x2F;finally, call the update method of the particle node to apply extra animations
			if (this.onUpdateParticleEnd !== null) {
				this.onUpdateParticleEnd(particle);
			}

			return isAlive;
		},

		&#x2F;**
		 * @public
		 * @method initParticle
		 * @param {CGSGParticle} particle
		 * @param {Number} index
		 *&#x2F;
		initParticle : function (particle, index) {
			particle.init();
			&#x2F;&#x2F;set a random position inside the region of this emitter
			particle.initPosition(Math.random() * this.region.dimension.width,
			                      Math.random() * this.region.dimension.height);

			&#x2F;&#x2F;set a random direction inside the angle
			var velocity = this.velocity.copy();
			var halfAngle = this.angle &#x2F; 2.0;
			velocity.rotate(-halfAngle + Math.random() * this.angle);
			particle.initVelocity(velocity);

			particle.initSpeedThreshold(-this.speedThreshold + Math.random() * this.speedThreshold * 2.0);

			if (this.onInitParticle !== null) {
				this.onInitParticle({index : index, particle : particle});
			}
		},

		&#x2F;**
		 * Add a force to the emitter
		 * @public
		 * @method addForce
		 * @param {CGSGVector2D} vector
		 * @param {Number} ttl time to live of the force
		 * @return {Object}
		 *&#x2F;
		addForce : function (vector, ttl) {
			var force = {vector : vector, ctl : ttl, age : 0};
			this._forces.push(force);
			return force;
		},

		&#x2F;**
		 * Remove a previously added force
		 * @public
		 * @method removeForce
		 * @param {Object} force
		 *&#x2F;
		removeForce : function (force) {
			this._forces.without(force);
		}&#x2F;*,

	 addImpulse : function(point, force, ttl) {
	 for (var p = 0; p &lt; this._particles.length; p++) {
	 this._particles[p].addImpulse(point, force, ttl);
	 }
	 }*&#x2F;
	}
);

&#x2F;**
 * A particle System object.
 * @class CGSGParticleSystem
 * @extends {CGSGNode}
 * @module Animation
 * @submodule ParticleSystem
 * @type {CGSGParticleSystem}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGParticleSystem = CGSGNode.extend(
	{
		initialize : function (x, y) {
			this._super(x, y, 1, 1);

			&#x2F;**
			 * @property classType
			 * @type {String}
			 *&#x2F;
			this.classType = &quot;CGSGParticleSystem&quot;;

			&#x2F;**
			 * list of emitters
			 * @property emitters
			 * @type {Array}
			 *&#x2F;
			this.emitters = [];
			&#x2F;**
			 * list of attractors
			 * @property attractors
			 * @type {Array}
			 *&#x2F;
			this.attractors = [];
			&#x2F;**
			 * list of repulsors
			 * @property repulsors
			 * @type {Array}
			 *&#x2F;
			this.repulsors = [];

			this.isClickable = false;
			this.isResizable = false;
			this.isDraggable = false;
			this.isTraversable = false;

			&#x2F;&#x2F;factory pattern
			&#x2F;&#x2F;this.integrator = new CGSGParticleIntegratorEuler();
			&#x2F;&#x2F;this.integrator = new CGSGParticleIntegratorRK4();
		},

		&#x2F;**
		 * Add a force to all emitters
		 * @public
		 * @method addForce
		 * @param {CGSGVector2D} vector
		 *&#x2F;
		addForce : function (vector) {
			for (var e = 0; e &lt; this.emitters.length; e++) {
				this.emitters[e].addForce(vector);
			}
		},

		&#x2F;*addImpulse : function(point, force, ttl) {
		 for (var e = 0; e &lt; this.emitters.length; e++) {
		 this.emitters[e].addImpulse(point, force, ttl);
		 }
		 },*&#x2F;

		&#x2F;**
		 * Create a new emitter and return it
		 * @public
		 * @method addEmitter
		 * @param {CGSGNode} node
		 * @param {CGSGRegion} region
		 * @param {Number} nbParticlesMax
		 * @param {Number} velocity
		 * @param {Number} angle
		 * @param {Number} speed
		 * @param {Number} speedThreshold
		 * @param {Number} outflow
		 * @return {CGSGParticleEmitter}
		 *&#x2F;
		addEmitter : function (node, region, nbParticlesMax, velocity, angle, speed, speedThreshold, outflow) {
			var emitter = new CGSGParticleEmitter(node, region, nbParticlesMax, velocity, angle, speed, speedThreshold,
			                                      outflow);
			this.addChild(emitter);
			this.emitters.push(emitter);
			return emitter;
		},

		&#x2F;**
		 * Remove the emitter passed in parameter
		 * @public
		 * @method removeEmitter
		 * @param {CGSGParticleEmitter} emitter
		 *&#x2F;
		removeEmitter : function (emitter) {
			this.emitters.without(emitter);
			this.removeChild(emitter);
		},

		&#x2F;**
		 * @public
		 * @method addAttractor
		 * @param {CGSGPosition} position
		 * @param {Number} strength
		 * @param {Number} distance
		 * @return {Object}
		 *&#x2F;
		addAttractor : function (position, strength, distance) {
			var attractor = {
				position : position,
				strength : strength,
				distance : distance
			};
			this.attractors.push(attractor);
			return attractor;
		},

		&#x2F;**
		 * @public
		 * @method removeAttractor
		 * @param {Object} attractor
		 *&#x2F;
		removeAttractor : function (attractor) {
			this.attractors.without(attractor);
		},

		&#x2F;**
		 * @public
		 * @method addRepulsor
		 * @param {CGSGPosition} position
		 * @param {Number} strength
		 * @param {Number} distance
		 * @return {Object}
		 *&#x2F;
		addRepulsor : function (position, strength, distance) {
			var repulsor = {
				position : position,
				strength : strength,
				distance : distance
			};
			this.repulsors.push(repulsor);
			return repulsor;
		},

		&#x2F;**
		 * @public
		 * @method removeRepulsor
		 * @param {Object} repulsor
		 *&#x2F;
		removeRepulsor : function (repulsor) {
			this.repulsors.without(repulsor);
		},

		&#x2F;**
		 * override the CGSGNode &#x27;pickNode&#x27; method to return null due to performance
		 * @override
		 * @protected
		 * @method pickNode
		 * @param mousePosition
		 * @param absoluteScale
		 * @param ghostContext
		 * @param recursively
		 * @param condition
		 * @return {*}
		 *&#x2F;
		pickNode : function (mousePosition, absoluteScale, ghostContext, recursively, condition) {
			return null;
		},

		&#x2F;**
		 * @public
		 * @method copy
		 * @todo : TODO fill the method
		 * @return {CGSGParticleSystem}
		 *&#x2F;
		copy : function () {
			var node = new CGSGParticleSystem();
			node = this._super(node);

			return node;
		}
	}
);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
