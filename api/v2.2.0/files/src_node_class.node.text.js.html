<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/node/class.node.text.js - SceneGraph.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../../logo/logoCGSG_256x57.png" title="SceneGraph.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.2.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/CGSG.html">CGSG</a></li>
            
                <li><a href="../classes/CGSGAccordion.html">CGSGAccordion</a></li>
            
                <li><a href="../classes/CGSGAnimationManager.html">CGSGAnimationManager</a></li>
            
                <li><a href="../classes/CGSGAnimationMethod.html">CGSGAnimationMethod</a></li>
            
                <li><a href="../classes/CGSGBindEntry.html">CGSGBindEntry</a></li>
            
                <li><a href="../classes/CGSGButtonMode.html">CGSGButtonMode</a></li>
            
                <li><a href="../classes/CGSGCollisionGhostOnDemandTester.html">CGSGCollisionGhostOnDemandTester</a></li>
            
                <li><a href="../classes/CGSGCollisionManager.html">CGSGCollisionManager</a></li>
            
                <li><a href="../classes/CGSGCollisionMethod.html">CGSGCollisionMethod</a></li>
            
                <li><a href="../classes/CGSGCollisionRegionTester.html">CGSGCollisionRegionTester</a></li>
            
                <li><a href="../classes/CGSGCollisionTesterFactory.html">CGSGCollisionTesterFactory</a></li>
            
                <li><a href="../classes/CGSGColor.html">CGSGColor</a></li>
            
                <li><a href="../classes/CGSGCSSManager.html">CGSGCSSManager</a></li>
            
                <li><a href="../classes/CGSGDimension.html">CGSGDimension</a></li>
            
                <li><a href="../classes/CGSGEvent.html">CGSGEvent</a></li>
            
                <li><a href="../classes/CGSGEventManager.html">CGSGEventManager</a></li>
            
                <li><a href="../classes/CGSGHandleBox.html">CGSGHandleBox</a></li>
            
                <li><a href="../classes/CGSGImgManager.html">CGSGImgManager</a></li>
            
                <li><a href="../classes/CGSGInterpolator.html">CGSGInterpolator</a></li>
            
                <li><a href="../classes/CGSGInterpolatorLinear.html">CGSGInterpolatorLinear</a></li>
            
                <li><a href="../classes/CGSGInterpolatorTCB.html">CGSGInterpolatorTCB</a></li>
            
                <li><a href="../classes/CGSGKeyFrame.html">CGSGKeyFrame</a></li>
            
                <li><a href="../classes/CGSGMap.html">CGSGMap</a></li>
            
                <li><a href="../classes/CGSGMask.html">CGSGMask</a></li>
            
                <li><a href="../classes/CGSGMaskCache.html">CGSGMaskCache</a></li>
            
                <li><a href="../classes/CGSGMaskClip.html">CGSGMaskClip</a></li>
            
                <li><a href="../classes/CGSGMath.html">CGSGMath</a></li>
            
                <li><a href="../classes/CGSGNode.html">CGSGNode</a></li>
            
                <li><a href="../classes/CGSGNodeButton.html">CGSGNodeButton</a></li>
            
                <li><a href="../classes/CGSGNodeCircle.html">CGSGNodeCircle</a></li>
            
                <li><a href="../classes/CGSGNodeColorPicker.html">CGSGNodeColorPicker</a></li>
            
                <li><a href="../classes/CGSGNodeCurveTCB.html">CGSGNodeCurveTCB</a></li>
            
                <li><a href="../classes/CGSGNodeDomElement.html">CGSGNodeDomElement</a></li>
            
                <li><a href="../classes/CGSGNodeEllipse.html">CGSGNodeEllipse</a></li>
            
                <li><a href="../classes/CGSGNodeImage.html">CGSGNodeImage</a></li>
            
                <li><a href="../classes/CGSGNodeLine.html">CGSGNodeLine</a></li>
            
                <li><a href="../classes/CGSGNodeSlider.html">CGSGNodeSlider</a></li>
            
                <li><a href="../classes/CGSGNodeSliderHandle.html">CGSGNodeSliderHandle</a></li>
            
                <li><a href="../classes/CGSGNodeSprite.html">CGSGNodeSprite</a></li>
            
                <li><a href="../classes/CGSGNodeSquare.html">CGSGNodeSquare</a></li>
            
                <li><a href="../classes/CGSGNodeTabMenu.html">CGSGNodeTabMenu</a></li>
            
                <li><a href="../classes/CGSGNodeText.html">CGSGNodeText</a></li>
            
                <li><a href="../classes/CGSGNodeWebview.html">CGSGNodeWebview</a></li>
            
                <li><a href="../classes/CGSGParticle.html">CGSGParticle</a></li>
            
                <li><a href="../classes/CGSGParticleEmitter.html">CGSGParticleEmitter</a></li>
            
                <li><a href="../classes/CGSGParticleSystem.html">CGSGParticleSystem</a></li>
            
                <li><a href="../classes/CGSGPickNodeMethod.html">CGSGPickNodeMethod</a></li>
            
                <li><a href="../classes/CGSGPosition.html">CGSGPosition</a></li>
            
                <li><a href="../classes/CGSGRegion.html">CGSGRegion</a></li>
            
                <li><a href="../classes/CGSGRotation.html">CGSGRotation</a></li>
            
                <li><a href="../classes/CGSGScale.html">CGSGScale</a></li>
            
                <li><a href="../classes/CGSGSceneGraph.html">CGSGSceneGraph</a></li>
            
                <li><a href="../classes/CGSGSection.html">CGSGSection</a></li>
            
                <li><a href="../classes/CGSGTimeline.html">CGSGTimeline</a></li>
            
                <li><a href="../classes/CGSGTraverser.html">CGSGTraverser</a></li>
            
                <li><a href="../classes/CGSGVector2D.html">CGSGVector2D</a></li>
            
                <li><a href="../classes/CGSGView.html">CGSGView</a></li>
            
                <li><a href="../classes/CGSGWEBVIEWMODE.html">CGSGWEBVIEWMODE</a></li>
            
                <li><a href="../classes/CGSGWrapMode.html">CGSGWrapMode</a></li>
            
                <li><a href="../classes/GLOBAL_CONSTANTS.html">GLOBAL_CONSTANTS</a></li>
            
                <li><a href="../classes/GLOBAL_METHODS.html">GLOBAL_METHODS</a></li>
            
                <li><a href="../classes/GLOBAL_PROPERTIES.html">GLOBAL_PROPERTIES</a></li>
            
                <li><a href="../classes/UTIL_ARRAY.html">UTIL_ARRAY</a></li>
            
                <li><a href="../classes/WUICCGSGNodeImageFactory.html">WUICCGSGNodeImageFactory</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animation.html">Animation</a></li>
            
                <li><a href="../modules/Collision.html">Collision</a></li>
            
                <li><a href="../modules/Math.html">Math</a></li>
            
                <li><a href="../modules/Node.html">Node</a></li>
            
                <li><a href="../modules/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="../modules/Scene.html">Scene</a></li>
            
                <li><a href="../modules/Util.html">Util</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/node/class.node.text.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * Copyright (c) 2014 Gwennael Buchet
 *
 * License/Terms of Use
 *
 * Permission is hereby granted, free of charge and for the term of intellectual property rights on the Software, to any
 * person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to use, copy, modify
 * and propagate free of charge, anywhere in the world, all or part of the Software subject to the following mandatory conditions:
 *
 *   â€¢    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  Any failure to comply with the above shall automatically terminate the license and be construed as a breach of these
 *  Terms of Use causing significant harm to Gwennael Buchet.
 *
 *  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  Except as contained in this notice, the name of Gwennael Buchet shall not be used in advertising or otherwise to promote
 *  the use or other dealings in this Software without prior written authorization from Gwennael Buchet.
 *
 *  These Terms of Use are subject to French law.
 */

/**
 * List the methods to wrap the text. Used by {CGSGNodeText} Node.
 * @class CGSGWrapMode
 * @type {Object}
 * @author Gwennael Buchet (gwennael.buchet@gmail.com)
 * @example
 *      myTextNode.setWrapMode(CGSGWrapMode.WORD, true);
 */
var CGSGWrapMode = {
    /**
     * @property WORD
     */
    WORD    : {space: &quot; &quot;},
    /**
     * @property LETTER
     */
    LETTER  : {space: &quot;&quot;},
    /**
     * @property SENTENCE
     */
    SENTENCE: {space: &quot;.&quot;}
};

/**
 * A CGSGNodeText represent a basic circle
 *
 * @class CGSGNodeText
 * @module Node
 * @extends CGSGNode
 * @constructor
 * @param {Number} x Relative position on X
 * @param {Number} y Relative position on Y
 * @param {String} text Text to display
 * @type {CGSGNodeText}
 * @author Gwennael Buchet (gwennael.buchet@gmail.com)
 */
var CGSGNodeText = CGSGNode.extend(
    {
        //noinspection BadExpressionStatementJS
        initialize: function (x, y, text, mustRecomputeDimension) {
            this._super(x, y);

            /**
             * @property _text
             * @type {String}
             * @private
             */
            this._text = &quot;&quot;;
            /**
             * Size of the text, in pt
             * @property _size
             * @default 18
             * @type {Number}
             * @private
             */
            this._size = 0;
            /**
             * Possible values : &quot;left&quot;, &quot;right&quot;, &quot;center&quot;
             * @property _align
             * @default &quot;left&quot;
             * @type {String}
             * @private
             */
            this._align = null;
            /**
             * Possible values : &quot;top&quot;, &quot;hanging&quot;, &quot;middle&quot;, &quot;alphabetic&quot;, &quot;ideographic&quot;, &quot;bottom&quot;
             * @property _textBaseline
             * @default &quot;top&quot;
             * @type {String}
             * @private
             */
            this._textBaseline = &quot;top&quot;;
            /**
             * @property _strokeColor
             * @type {String}
             * @private
             */
            this._strokeColor = null;

            /**
             * @property crossed
             * @default false
             * @type {Boolean}
             * @private
             */
            this.crossed = false;

            /**
             * @property _style
             * @default &quot;&quot;
             * @type {String}
             * @private
             */
            this._style = &quot;&quot;;
            /**
             * @property _typo
             * @default &quot;Arial&quot;
             * @type {String}
             * @private
             */
            this._typo = null;

            this._sizeT=NaN;
            this._variant=null;
            this._weight=NaN;

            this._transform=null;
            /**
             * Max width for the text. If -1, so no max will be used
             * @property _maxWidth
             * @type {Number}
             * @private
             */
            this._maxWidth = -1;
            /**
             * Line height when wrap the text.
             * A line height is the size between 2 tops of line
             * @property _lineHeight
             * @default this._size
             * @type {Number}
             * @private
             */
            this._lineHeight = this._size;
            this._userModifMaxW = false;
            /**
             * @property _wrapMode
             * @default CGSGWrapMode.LETTER
             * @type {Object}
             * @private
             */
            this._wrapMode = CGSGWrapMode.LETTER;

            /**
             * List of sections in the text. a section is delimited by a Carriage Return
             * @property _sections
             * @type {Array}
             * @private
             */
            this._sections = [];

            /**
             * The string to replace the tabulation characters
             * @property _tabulation
             * @type {String}
             * @private
             */
            this._tabulation = &quot;    &quot;;

            /**
             * Method to select the text
             * @property pickNodeMethod
             * @type {Object}
             */
            this.pickNodeMethod = CGSGPickNodeMethod.GHOST;

            /**
             * Metrics of the text.
             * Computed each frame it is rendered. Contains only width.
             * Use getWidth() and getHeight() methods to get correct values
             * @readonly
             * @property metrics
             * @type {Object}
             */
            this.metrics = {width: 1};

            /**
             * number of lines in the text
             * @property _nbLines
             * @type {Number}
             * @private
             */
            this._nbLines = 1;

            /**
             * @property classType
             * @type {String}
             */
            this.classType = &quot;CGSGNodeText&quot;;

            this.setText(text, mustRecomputeDimension !== false);

            this.setClass(&quot;cgsg-p&quot;);
            this.resizeTo(this.getWidth(), this.getHeight());
        },

        /**
         * Reload theme (colors, ...) from loaded CSS file
         * @method invalidateTheme
         */
        invalidateTheme: function () {
            this._super();

            var cl = CGSG.cssManager.getAttrInArray(this._cls, &quot;color&quot;);
            var style = CGSG.cssManager.getAttrInArray(this._cls, &quot;font-style&quot;);
            var variant = CGSG.cssManager.getAttrInArray(this._cls, &quot;font-variant&quot;);
            var weight = CGSG.cssManager.getAttrInArray(this._cls, &quot;font-weight&quot;);
            var size = CGSG.cssManager.getAttrInArray(this._cls, &quot;font-size&quot;);
            var family = CGSG.cssManager.getAttrInArray(this._cls, &quot;font-family&quot;);
            var height = CGSG.cssManager.getAttrInArray(this._cls, &quot;line-height&quot;);
            var align = CGSG.cssManager.getAttrInArray(this._cls, &quot;text-align&quot;);
            var transform = CGSG.cssManager.getAttrInArray(this._cls, &quot;text-transform&quot;);
            var strokeWidth = CGSG.cssManager.getAttrInArray(this._cls, &quot;-webkit-text-stroke-width&quot;);
            if (!cgsgExist(strokeWidth)) {
                strokeWidth = CGSG.cssManager.getAttrInArray(this._cls, &quot;text-stroke-width&quot;);
            }
            var strokeColor = CGSG.cssManager.getAttrInArray(this._cls, &quot;-webkit-text-stroke-color&quot;);
            if (!cgsgExist(strokeColor)) {
                strokeColor = CGSG.cssManager.getAttrInArray(this._cls, &quot;text-stroke-color&quot;);
            }

            if (cgsgExist(cl)) {
                //value is given as &quot;rgb(xx, yy, zz)&quot;. Let&#x27;s convert it to hex
                var rgb = CGSGColor.fromString(cl);
                this.color = CGSGColor.rgb2hex(rgb.r, rgb.g, rgb.b);
            }
            if (cgsgExist(style)) {
                this._style = style;
            }
            if (cgsgExist(variant)) {
                this._variant = variant;
            }
            if (cgsgExist(weight)) {
                this._weight = weight;
            }
            if (cgsgExist(size)) {
                this._sizeT = size;
                this._size = CGSG.cssManager.getNumber(size);
                this._lineHeight = this._size;
            }
            if (cgsgExist(family)) {
                this._typo = family;
            }
            if (cgsgExist(height)) {
                this._lineHeight = height;
            }
            if (cgsgExist(align)) {
                this._align = align;
            }
            if (cgsgExist(transform)) {
                this._transform = transform;
            }
            if (cgsgExist(strokeWidth)) {
                this.lineWidth = strokeWidth;
            }
            if (cgsgExist(strokeColor)) {
                this.lineColor = strokeColor;
            }

            this._invalidateFont();

            if (!this._userModifMaxW &amp;&amp; cgsgExist(this.metrics)) {
                this._maxWidth = NaN;
                this.computeRealDimension();
                //this._setMaxW(this.getWidth() + 1, true);
            }
        },

        setPrecomputed: function (p) {
            //nop
        },

        _invalidateFont: function () {
            var st = (cgsgExist(this._style) &amp;&amp; this._style.length &gt; 0) ? (this._style + &#x27; &#x27;) : &quot;&quot;;
            var va = (cgsgExist(this._variant) &amp;&amp; this._variant.length &gt; 0) ? (this._variant + &#x27; &#x27;) : &quot;&quot;;
            var we = (cgsgExist(this._weight) &amp;&amp; this._weight.length &gt; 0) ? (this._weight + &#x27; &#x27;) : &quot;&quot;;
            var si = (cgsgExist(this._sizeT)) ? (this._sizeT + &#x27; &#x27;) : &quot;&quot;;
            var ty = (cgsgExist(this._typo) &amp;&amp; this._typo.length &gt; 0) ? (this._typo + &#x27; &#x27;) : &quot;&quot;;

            this._fullfont = st + va + we + si + ty;
        },

        /**
         * Set the wrap mode for the text if maxWidth &gt; 0
         * @method setWrapMode
         * @param {Object} mode a CGSGWrapMode (CGSGWrapMode.WORD, CGSGWrapMode.LETTER)
         * @param {Boolean} mustRecomputeDimension (default : true)
         * @example
         *      myTextNode.setWrapMode(CGSGWrapMode.WORD, true);
         */
        setWrapMode: function (mode, mustRecomputeDimension) {
            this._wrapMode = mode;
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * Set the string to replace the tabulation characters
         * @method setTabulationString
         * @param {String} tab TExt to replace tabulation (ie: 4 spaces, ...)
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setTabulationString: function (tab, mustRecomputeDimension) {
            this._tabulation = tab;
            this._text = this._text.replace(/(\t)/g, this._tabulation);
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * @method setText
         * @param {String} t the new text
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setText: function (t, mustRecomputeDimension) {
            this._text = t;
            this._text = this._text.replace(/(\r\n|\n\r|\r|\n)/g, &quot;\n&quot;);
            this._text = this._text.replace(/(\t)/g, this._tabulation);
            this._sections = this._text.split(&quot;\n&quot;);

            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }

            //if no maxWidth is already defined, then set it now with current width + 1
            //if ((!cgsgExist(this._maxWidth) || this._maxWidth &lt;= 0) &amp;&amp; this.getWidth() &gt; 0) {
            if (!this._userModifMaxW) {
                this._maxWidth = NaN;
                //this._setMaxW(this.getWidth() + 1, true);
            }

            this.invalidate();
        },

        /**
         * @method setTextBaseline
         * @param {String} b A String (Possible values : &quot;top&quot;, &quot;hanging&quot;, &quot;middle&quot;, &quot;alphabetic&quot;, &quot;ideographic&quot;, &quot;bottom&quot;)
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setTextBaseline: function (b, mustRecomputeDimension) {
            this._textBaseline = b;
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * @method setStyle
         * @param {String} s &quot;&quot; by default
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setStyle: function (s, mustRecomputeDimension) {
            this._style = s;
            this._invalidateFont();
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * Line height when wrap the text.
         * A line height is the size between 2 tops of line
         * @method setLineHeight
         * @param {Number} l height of a line
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setLineHeight: function (l, mustRecomputeDimension) {
            this._lineHeight = l;
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * @method setSize
         * @param {Number} s the new size (an integer)
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setSize: function (s, mustRecomputeDimension) {
            this._size = s;
            this._invalidateFont();
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * @method setTypo
         * @param {String} t &quot;Arial&quot; by default
         * @param {Boolean} mustRecomputeDimension (default : true)
         */
        setTypo: function (t, mustRecomputeDimension) {
            this._typo = t;
            this._invalidateFont();
            this.invalidate();
            if (mustRecomputeDimension !== false) {
                this.computeRealDimension();
            }
        },

        /**
         * @method setWeight
         * @param w
         */
        setWeight: function (w) {
            this._weight = w;
            this._invalidateFont();
            this.invalidate();
        },

        /**
         * @method setVariant
         * @param v
         */
        setVariant: function (v) {
            this._variant = v;
            this._invalidateFont();
            this.invalidate();
        },

        /**
         * @method setTextAlign
         * @param {String} a A String (Possible values : &quot;left&quot;, &quot;right&quot;, &quot;center&quot;)
         */
        setTextAlign: function (a) {
            this._align = a;
            this.invalidate();
        },

        /**
         * compute the real dimension of the text
         * @method computeRealDimension
         */
        computeRealDimension: function () {
            this.metrics.width = 0;
            var fakeCanvas = document.createElement(&#x27;canvas&#x27;);
            var fakeContext = fakeCanvas.getContext(&#x27;2d&#x27;);

            this._doRender(fakeContext, false);

            fakeCanvas.width = 0;
            fakeCanvas.height = 0;
            fakeCanvas = null;
        },

        /**
         * @method _setMaxW
         * @param {Number} m Max Width for the text
         * @param {Boolean} invalidDim (default : true)
         * @private
         */
        _setMaxW: function (m, invalidDim) {
            this._maxWidth = m;
            if (this._maxWidth &gt; 0) {
                this.dimension.width = m;
                if (invalidDim !== false) {
                    this.computeRealDimension();
                }
            }
        },

        /**
         * @method setMaxWidth
         * @param {Number} m Max Width for the text
         * @param {Boolean} invalidDim (default : true)
         */
        setMaxWidth:function(m, invalidDim) {
          this._userModifMaxW = true;
            this._setMaxW(m, invalidDim);
        },

        /**
         * Increase/decrease current dimension with adding values
         * @method resizeWith
         * @param {Number} w
         * @param {Number} h
         * */
        resizeWith: function (w, h) {
            if (this._maxWidth + w &gt; 0) {
                this._afterResize(this._maxWidth + w);
            }
        },

        _afterResize: function (m) {
            var w = this.getWidth();
            this._maxWidth = m;
            //this.dimension.width = m;//Math.max(m, this.dimension.width);
            this.computeRealDimension();

            if (this._nbLines === 1 &amp;&amp; this.getWidth() &lt;= w) {
                this._maxWidth = this.getWidth() + 1;
            }

            this._applyContraintsToFollowers();
            this._endResize();
        },

        /**
         * Custom rendering
         * @method render
         * @protected
         * @param {CanvasRenderingContext2D} context the context into render the node
         * */
        render: function (context) {
            context.fillStyle = this.color || this.bkgcolors[0];

            this._doRender(context, false);
        },

        /**
         * Do the effective render
         * @method _doRender
         * @param {CanvasRenderingContext2D} context the context into render the node
         * @param {Boolean} isGhostmode. If true a square will be rendered instead of the text.
         * @private
         */
        _doRender: function (context, isGhostmode) {
            context.font = this._fullfont;

            context.textAlign = this._align;
            context.textBaseline = this._textBaseline;

            var s = 0, textW = 0, posX = 0, posY = 0, mt;
            if (this.crossed) {
                context.save();
                context.strokeStyle = &quot;grey&quot;;
                context.moveTo(this.getWidth(), 3);
                context.lineTo(0, this.getHeight() + 3);
                context.stroke();
                context.restore();
            }
            if (!cgsgExist(this._maxWidth) || this._maxWidth &lt;= 0) {
                posX = this._computeDecalX(this.getWidth());
                for (s = 0; s &lt; this._sections.length; s++) {
                    textW = context.measureText(this._sections[s]).width;
                    this._drawText(this._sections[s], posX, posY, context, isGhostmode, textW);
                    posY += this._lineHeight;
                }
                this._nbLines = this._sections.length;
            }
            else { //if (this._maxWidth &gt; 0
                this._nbLines = 0;

                for (s = 0; s &lt; this._sections.length; s++) {
                    var words = this._sections[s].split(this._wrapMode.space);
                    var nbWords = 0;
                    var testLine = &quot;&quot;;
                    posY = 0;
                    textW = 0;
                    if (words.length === 1) {
                        textW = context.measureText(testLine).width;
                        posY = this._nbLines * this._lineHeight;
                        posX = this._computeDecalX(this.getWidth());
                        this._drawText(testLine, posX, posY, context, isGhostmode, textW);
                        this._nbLines++;
                    }
                    else {
                        while (nbWords &lt; words.length) {

                            testLine = words[nbWords];
                            mt = context.measureText(testLine + this._wrapMode.space + words[nbWords + 1]);
                            while (mt.width &lt; (this._maxWidth /*- 5*/) &amp;&amp;
                                   nbWords &lt; words.length - 1
                                ) {
                                if (testLine !== &quot;&quot;) {
                                    testLine += this._wrapMode.space;
                                }
                                testLine += words[++nbWords];
                                mt = context.measureText(testLine + this._wrapMode.space + words[nbWords + 1]);
                            }

                            textW = context.measureText(testLine).width;
                            posY = this._nbLines * this._lineHeight;
                            posX = this._computeDecalX(this.getWidth());
                            this._drawText(testLine, posX, posY, context, isGhostmode, textW);
                            this._nbLines++;

                            ++nbWords;
                        }
                    }
                }

            }

            //region constraint

            var rgc;
            if (this.nodeConstraint !== null) {
                rgc = this.nodeConstraint.getAbsoluteRegion();
            }
            else {
                rgc = this.regionConstraint;
            }
            if (rgc !== null) {
                var r = this.getAbsoluteRegion();
                var d = this.getAbsBottom() - (rgc.position.x + rgc.dimension.height);
                if (d &gt; 0) {
                    this.translateWith(0, -d);
                }
            }
        },

        /**
         * @method _drawText
         * @param {String} text
         * @param {Number} x
         * @param {Number} y
         * @param {CanvasRenderingContext2D} context the context into render the node
         * @param {Boolean} isGhostmode
         * @param {Number} width
         * @private
         */
        _drawText: function (text, x, y, context, isGhostmode, width) {
            if (cgsgExist(this._transform)) {
                if (this._transform === &quot;capitalize&quot;) {
                    text = text.capitalize();
                }
                if (this._transform === &quot;lowercase&quot;) {
                    text = text.toLowerCase();
                }
                if (this._transform === &quot;uppercase&quot;) {
                    text = text.toUpperCase();
                }
            }

            if (isGhostmode) {
                this._drawSquare(x, y, width, context);
                return;
            }
            //uncomment this to debug
            //context.fillStyle = &quot;red&quot;;
            //this._drawSquare(x, y, width, context);
            //context.fillStyle = this.color;

            if (cgsgExist(this.lineWidth) &amp;&amp; this.lineWidth &gt; 0) {
                context.strokeText(text, x, y);
            }

            if (cgsgExist(context.fillStyle) &amp;&amp; this.globalAlpha &gt; 0) {
                context.fillText(text, x, y);
            }

            var mt = context.measureText(text);
            if (mt.width &gt; this.metrics.width) {
                this.metrics.width = mt.width;
            }
        },

        /**
         * @method _drawSquare
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {CanvasRenderingContext2D} context the context into render the node
         * @private
         */
        _drawSquare: function (x, y, width, context) {
            context.fillRect(x - this._computeDecalX(width), y + this._computeDecalY(), width, this._size);
        },

        /**
         * @method getHeight
         * @return {Number}
         */
        getHeight: function () {
            if (this._nbLines === 0) {
                return this._nbLines;
            }

            return ((this._nbLines - 1) * this._lineHeight) + this._size;
        },

        /**
         * @method getWidth
         * @return {Number}
         */
        getWidth: function () {
            return this.metrics.width;
        },

        /**
         * @private
         * @method _computeDecalX
         * @return {Number}
         */
        _computeDecalX: function (width) {
            var decalX = 0;
            if (this._align === &quot;start&quot; || this._align === &quot;left&quot;) {
                decalX = 0.0;
            }
            else if (this._align === &quot;center&quot;) {
                decalX = width / 2.0;
            }
            else if (this._align === &quot;end&quot; || this._align === &quot;right&quot;) {
                decalX = width;
            }

            return decalX;
        },

        /**
         * Browsers don&#x27;t render the text in the exact same way.
         * It can be few pixels of difference in Y position
         * @private
         * @method _computeDecalY
         * @return {Number}
         */
        _computeDecalY: function () {
            var decalY = 0;
            if (this._textBaseline === &quot;top&quot; || this._textBaseline === &quot;hanging&quot;) {
                decalY = this._size / cgsgCurrentExplorer.textDecalYTop;
            }
            else if (this._textBaseline === &quot;middle&quot;) {
                decalY = -this._size / cgsgCurrentExplorer.textDecalYMiddle;
            }
            else if (this._textBaseline === &quot;alphabetic&quot; || this._textBaseline === &quot;ideographic&quot;) {
                decalY = -this._size * cgsgCurrentExplorer.textDecalYAlpha;
            }
            else if (this._textBaseline === &quot;bottom&quot;) {
                decalY = -this._size * cgsgCurrentExplorer.textDecalYBottom;
            }

            return decalY;
        },

        /**
         * Override ghost &quot;do rendering&quot; function.
         *
         * @method doRenderGhost
         * @protected
         * @param {CanvasRenderingContext2D} ghostContext The context for the ghost rendering
         */
        doRenderGhost: function (ghostContext) {
            //save current state
            this.beforeRenderGhost(ghostContext);

            if (this.globalAlpha &gt; 0) {
                this.renderGhost(ghostContext);
                ghostContext.fillStyle = CGSG.ghostColor;

                this._doRender(ghostContext, true);
            }

            //restore state
            this.afterRenderGhost(ghostContext);
        },

        /**
         * Render the resize handler
         * @protected
         * @method renderBoundingBox
         * @param {CanvasRenderingContext2D} context the context into render the node
         */
        renderBoundingBox: function (c) {
            var decalX = 0;
            var decalY = this._computeDecalY();

            //this._absPos = this.getAbsPosition(false);
            //this._absSca = this.getAbsScale(false);

            var height = this.getHeight();
            var width = this.getWidth();

            if (cgsgExist(this.selectionLineWidth) &amp;&amp; this.selectionLineWidth &gt; 0) {
                c.strokeStyle = this.selectionLineColor;

                c.lineWidth = this.selectionLineWidth / this._absSca.y;
                c.beginPath();
                //top line
                c.moveTo(decalX, decalY);
                c.lineTo(width, decalY);
                //bottom line
                c.moveTo(decalX, decalY + height);
                c.lineTo(width, decalY + height);
                c.stroke();
                c.closePath();

                c.lineWidth = this.selectionLineWidth / this._absSca.x;
                c.beginPath();
                //left line
                c.moveTo(decalX, decalY);
                c.lineTo(decalX, decalY + height);
                //right line
                c.moveTo(decalX + width, decalY);
                c.lineTo(decalX + width, decalY + height);
                c.stroke();
                c.closePath();
            }

            //draw the resize handles
            if (this.isResizable) {
                // draw the handle boxes
                var halfX = this.handleSize / (2 * this._absSca.x);
                var halfY = this.handleSize / (2 * this._absSca.y);

                // 0  1  2
                // 3     4
                // 5  6  7

                // top left, middle, right
                this.handles[0].translateTo(-halfX, -halfY + decalY);
                this.handles[1].translateTo(width / 2 - halfX, -halfY + decalY);
                this.handles[2].translateTo(width - halfX, -halfY + decalY);

                // middle left
                this.handles[3].translateTo(-halfX, height / 2 - halfY + decalY);

                // middle right
                this.handles[4].translateTo(width - halfX,
                                            height / 2 - halfY + decalY);

                // bottom left, middle, right
                this.handles[6].translateTo(width / 2 - halfX,
                                            height - halfY + decalY);
                this.handles[5].translateTo(-halfX, height - halfY + decalY);
                this.handles[7].translateTo(width - halfX,
                                            height - halfY + decalY);

                for (var i = 0; i &lt; 8; i++) {
                    this.handles[i].size = this.handleSize;
                    this.handles[i].fillColor = this.handleColor;
                    this.handles[i].strokeColor = this.selectionLineColor;
                    this.handles[i].lineWidth = this.selectionLineWidth;
                    this.handles[i].render(c);
                }
            }
        },

        /**
         * @method copy
         * @return {CGSGNodeText} a copy of this node
         */
        copy: function () {
            var node = new CGSGNodeText(this.position.x, this.position.y, this._text);
            //call the super method
            node = this._super(node);

            node.setSize(this._size, false);
            node.setTextAlign(this._align, false);
            node.setTextBaseline(this._textBaseline, false);
            node.setStroke(this.lineWidth, false);
            node.setTypo(this._typo, false);
            node._setMaxW(this._maxWidth, false);
            node.setLineHeight(this._lineHeight, false);
            node.setWrapMode(this._wrapMode, false);
            node.setTabulationString(this._tabulation, false);
            node.pickNodeMethod = this.pickNodeMethod;

            this.setText(this._text, true);
            this.resizeTo(this.getWidth(), this.getHeight());
            return node;
        }
    }
);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
