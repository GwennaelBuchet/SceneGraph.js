<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\class.view.js - cgSceneGraph</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CGSG.html">CGSG</a></li>
            
                <li><a href="..&#x2F;classes/CGSGAnimationKey.html">CGSGAnimationKey</a></li>
            
                <li><a href="..&#x2F;classes/CGSGBindEntry.html">CGSGBindEntry</a></li>
            
                <li><a href="..&#x2F;classes/CGSGButtonMode.html">CGSGButtonMode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionGhostOnDemandTester.html">CGSGCollisionGhostOnDemandTester</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionManager.html">CGSGCollisionManager</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionMethod.html">CGSGCollisionMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionRegionTester.html">CGSGCollisionRegionTester</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionTesterFactory.html">CGSGCollisionTesterFactory</a></li>
            
                <li><a href="..&#x2F;classes/CGSGColor.html">CGSGColor</a></li>
            
                <li><a href="..&#x2F;classes/CGSGDimension.html">CGSGDimension</a></li>
            
                <li><a href="..&#x2F;classes/CGSGEvent.html">CGSGEvent</a></li>
            
                <li><a href="..&#x2F;classes/CGSGEventManager.html">CGSGEventManager</a></li>
            
                <li><a href="..&#x2F;classes/CGSGHandleBox.html">CGSGHandleBox</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMap.html">CGSGMap</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMask.html">CGSGMask</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMaskCache.html">CGSGMaskCache</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMaskClip.html">CGSGMaskClip</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMath.html">CGSGMath</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNode.html">CGSGNode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeButton.html">CGSGNodeButton</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeCircle.html">CGSGNodeCircle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeColorPicker.html">CGSGNodeColorPicker</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeEllipse.html">CGSGNodeEllipse</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeImage.html">CGSGNodeImage</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSprite.html">CGSGNodeSprite</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSquare.html">CGSGNodeSquare</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeTabMenu.html">CGSGNodeTabMenu</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeText.html">CGSGNodeText</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeWebview.html">CGSGNodeWebview</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticle.html">CGSGParticle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleEmitter.html">CGSGParticleEmitter</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleSystem.html">CGSGParticleSystem</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPickNodeMethod.html">CGSGPickNodeMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPosition.html">CGSGPosition</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRegion.html">CGSGRegion</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRotation.html">CGSGRotation</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScale.html">CGSGScale</a></li>
            
                <li><a href="..&#x2F;classes/CGSGSceneGraph.html">CGSGSceneGraph</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTimeline.html">CGSGTimeline</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTraverser.html">CGSGTraverser</a></li>
            
                <li><a href="..&#x2F;classes/CGSGVector2D.html">CGSGVector2D</a></li>
            
                <li><a href="..&#x2F;classes/CGSGView.html">CGSGView</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWEBVIEWMODE.html">CGSGWEBVIEWMODE</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWrapMode.html">CGSGWrapMode</a></li>
            
                <li><a href="..&#x2F;classes/GLOBAL_CONSTANTS.html">GLOBAL_CONSTANTS</a></li>
            
                <li><a href="..&#x2F;classes/GLOBAL_METHODS.html">GLOBAL_METHODS</a></li>
            
                <li><a href="..&#x2F;classes/GLOBAL_PROPERTIES.html">GLOBAL_PROPERTIES</a></li>
            
                <li><a href="..&#x2F;classes/UTIL_ARRAY.html">UTIL_ARRAY</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Animation.html">Animation</a></li>
            
                <li><a href="..&#x2F;modules/Collision.html">Collision</a></li>
            
                <li><a href="..&#x2F;modules/Math.html">Math</a></li>
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="..&#x2F;modules/Scene.html">Scene</a></li>
            
                <li><a href="..&#x2F;modules/Util.html">Util</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\class.view.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2012  Capgemini Technology Services (hereinafter “Capgemini”)
 *
 * License&#x2F;Terms of Use
 *
 * Permission is hereby granted, free of charge and for the term of intellectual property rights on the Software, to any
 * person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to use, copy, modify
 * and propagate free of charge, anywhere in the world, all or part of the Software subject to the following mandatory conditions:
 *
 *   •    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  Any failure to comply with the above shall automatically terminate the license and be construed as a breach of these
 *  Terms of Use causing significant harm to Capgemini.
 *
 *  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  Except as contained in this notice, the name of Capgemini shall not be used in advertising or otherwise to promote
 *  the use or other dealings in this Software without prior written authorization from Capgemini.
 *
 *  These Terms of Use are subject to French law.
 * *&#x2F;

&quot;use strict&quot;;

&#x2F;**
 * Provides requestAnimationFrame in a cross browser way.
 * @property cgsgGlobalRenderingTimer
 * @private
 * @type {Number}
 *&#x2F;
var cgsgGlobalRenderingTimer = null;
&#x2F;&#x2F;var cgsgGlobalFramerate = CGSG_DEFAULT_FRAMERATE;
(function () {
    var lastTime = 0;
    var vendors = [&#x27;ms&#x27;, &#x27;moz&#x27;, &#x27;webkit&#x27;, &#x27;o&#x27;];
    for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + &#x27;RequestAnimationFrame&#x27;];
        window.cancelAnimationFrame =
            window[vendors[x] + &#x27;CancelAnimationFrame&#x27;] || window[vendors[x] + &#x27;CancelRequestAnimationFrame&#x27;];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 17 - (currTime - lastTime)); &#x2F;&#x2F;1000&#x2F;60 = 16.667
            cgsgGlobalRenderingTimer = window.setTimeout(function () {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            &#x2F;&#x2F;return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }
}());

&#x2F;**
 * Represent the scene of the application.
 * It encapsulates the scene graph itself and several methods to track mouse and touch events, ...
 *
 * @class CGSGView
 * @constructor
 * @module Scene
 * @main Scene
 * @extends {Object}
 * @param {HTMLElement} canvas a handler to the canvas HTML element
 * @type {CGSGView}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGView = CGSGObject.extend(
    {
        initialize: function (canvas) {

            &#x2F;&#x2F;detect the current explorer to apply correct parameters
            cgsgDetectCurrentExplorer();

            &#x2F;&#x2F;for IE10 on Win8 : disable the default touch actions
            if (typeof canvas.style.msTouchAction != &#x27;undefined&#x27;) {
                canvas.style.msTouchAction = &quot;none&quot;;
            }

            &#x2F;&#x2F;noinspection JSUndeclaredVariable
            CGSG.canvas = canvas;
            &#x2F;&#x2F;noinspection JSUndeclaredVariable
            CGSG.context = CGSG.canvas.getContext(&quot;2d&quot;);

            &#x2F;**
             * Multiselection boolean.
             * @property allowMultiSelect
             * @default true
             * @type {Boolean}
             *&#x2F;
            this.allowMultiSelect = true;

            &#x2F;**
             * Fill color for the drag selection selection rectangle
             * @property dragSelectFillColor
             * @default &quot;#C0C0C0&quot;
             * @type {String}
             *&#x2F;
            this.dragSelectFillColor = CGSG_DEFAULT_DRAG_SELECT_FILL_COLOR;

            &#x2F;**
             * Stroke color for the drag selection selection rectangle
             * @property dragSelectStrokeColor
             * @default &quot;#808080&quot;
             * @type {String}
             *&#x2F;
            this.dragSelectStrokeColor = CGSG_DEFAULT_DRAG_SELECT_STROKE_COLOR;

            &#x2F;**
             * Alpha value for the drag selection rectangle
             * @property dragSelectAlpha
             * @default 0.6
             * @type {Number}
             *&#x2F;
            this.dragSelectAlpha = CGSG_DEFAULT_DRAG_SELECT_ALPHA;

            &#x2F;&#x2F;noinspection JSUndeclaredVariable
            CGSG.sceneGraph = new CGSGSceneGraph(CGSG.canvas, CGSG.context);

            &#x2F;*
             * If true, framework will take care of multi-touch : NOT EFFECTIVE YET
             * @property multitouch
             * @default false
             * @type {Boolean}
             *&#x2F;
            &#x2F;&#x2F;this.multitouch = false;

            &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; @private &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
            &#x2F;**
             * @property _isRunning
             * @type {Boolean}
             * @private
             *&#x2F;
            this._isRunning = false;
            &#x2F;&#x2F; when set to true, the canvas will redraw everything
            &#x2F;&#x2F; invalidate() just sets this to false right now
            &#x2F;&#x2F; we want to call invalidate() whenever we make a change
            this._needRedraw = true;

            &#x2F;**
             * @property _frameContainer Handler to the HTML Element displaying the FPS
             * @type {HTMLElement}
             * @private
             *&#x2F;
            this._frameContainer = null;

            &#x2F;**
             * True if the [CTRL} key is being pressed
             * @property _keyDownedCtrl
             * @default false
             * @type {Boolean}
             * @private
             *&#x2F;
            this._keyDownedCtrl = false;

            &#x2F;**
             * @property _timerDblTouch
             * @default null
             * @type {Number}
             * @private
             *&#x2F;
            this._timerDblTouch = null;

            &#x2F;**
             * The delay between 2 touches to be considered as a dbl touch event.
             * To remove the double touch, just set it to 0
             * @property dblTouchDelay
             * @default CGSG_DEFAULT_DBLTOUCH_DELAY
             * @type {Number}
             *&#x2F;
            this.dblTouchDelay = CGSG_DEFAULT_DBLTOUCH_DELAY;

            &#x2F;**
             * Current positions of the mouse or touch (Array of CGSGPosition)
             * @property _mousePosition
             * @type {Array}
             * @private
             *&#x2F;
            this._mousePosition = [];
            this._mouseOldPosition = [];
            this._dragSelectStartMousePosition = [];
            this._dragSelectEndMousePosition = [];
            this._isDrag = false;
            this._isResizeDrag = false;
            this._isDragSelect = false;
            this._resizingDirection = -1;
            this._isDblClick = false;
            this._mouseUpCount = 0; &#x2F;&#x2F; counter used to identify dbl click action
            this._timeoutDblClick = null;
            this._isPressing = false;
            this._frameRatio = 0;

            &#x2F;**
             * @property _listCursors List of the names for the cursor when overring a handlebox
             * @type {Array}
             * @private
             *&#x2F;
            this._listCursors =
                [&#x27;nw-resize&#x27;, &#x27;n-resize&#x27;, &#x27;ne-resize&#x27;, &#x27;w-resize&#x27;, &#x27;e-resize&#x27;, &#x27;sw-resize&#x27;,
                    &#x27;s-resize&#x27;, &#x27;se-resize&#x27;];
            this._offsetX = 0;
            this._offsetY = 0;
            &#x2F;**
             * @property _selectedNode The current last selected node
             * @type {null}
             * @private
             *&#x2F;
            this._selectedNode = null;

            &#x2F;&#x2F;Experimental : double-buffer for the temporary rendering
            &#x2F;*this._dblCanvas = document.createElement(&#x27;canvas&#x27;);
             this._dblContext = null;*&#x2F;

            &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; INITIALIZATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

            &#x2F;&#x2F;use an external variable to define the scope of the processes
            var scope = this;
            CGSG.canvas.onmouseout = function(event) {
                scope.onMouseOutHandler(event);
            };

            CGSG.canvas.onmousedown = function (event) {
                scope.onMouseDown(event);
            };
            CGSG.canvas.onmouseup = function (event) {
                scope.onMouseUp(event);
            };
            CGSG.canvas.ondblclick = function (event) {
                scope.onMouseDblClick(event);
            };
            CGSG.canvas.onmousemove = function (event) {
                scope.onMouseMove(event);
            };
            document.onkeydown = function (event) {
                scope.onKeyDownHandler(event);
            };
            document.onkeyup = function (event) {
                scope.onKeyUpHandler(event);
            };
            CGSG.canvas.addEventListener(&#x27;touchstart&#x27;, function (event) {
                scope.onTouchStart(event);
            }, false);
            CGSG.canvas.addEventListener(&#x27;touchmove&#x27;, function (event) {
                scope.onTouchMove(event);
            }, false);
            CGSG.canvas.addEventListener(&#x27;touchend&#x27;, function (event) {
                scope.onTouchEnd(event);
            }, false);

            CGSG.canvas.addEventListener(&#x27;MSPointerDown&#x27;, function (event) {
                scope.onTouchStart(event);
            }, false);
            CGSG.canvas.addEventListener(&quot;MSPointerMove&quot;, function (event) {
                scope.onTouchMove(event);
            }, false);
            CGSG.canvas.addEventListener(&#x27;MSPointerUp&#x27;, function (event) {
                scope.onTouchEnd(event);
            }, false);

            this._lastUpdate = new Date().getTime();

            this._nodeMouseOver = null;

            &#x2F;**
             * Callback on click down on scene event.
             * @property onSceneClickStart
             * @default null
             * @type {Function}
             * @example
             *  this.onSceneClickStart = function (event) {
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onSceneClickStart = null;
            &#x2F;**
             * Callback on click up on scene event
             * @property onSceneClickEnd
             * @default null
             * @type {Function}
             * @example
             *  this.onSceneClickEnd = function (event) {
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onSceneClickEnd = null;
            &#x2F;**
             * Callback on double click start on scene event
             * @property onSceneDblClickStart
             * @default null
             * @type {Function}
             * @example
             *  this.onSceneDblClickStart = function (event) {
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onSceneDblClickStart = null;
            &#x2F;**
             * Callback on double click up on scene event
             * @property onSceneDblClickEnd
             * @default null
             * @type {Function}
             * @example
             *  this.onSceneDblClickEnd = function (event) {
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onSceneDblClickEnd = null;
            &#x2F;**
             * Callback on start rendering event
             * @property onRenderStart
             * @default null
             * @type {Function}
             * @example
             *  this.onSceneClickStart = function () {
			 *      &#x2F;&#x2F;...
			 *  }
             *&#x2F;
            this.onRenderStart = null;
            &#x2F;**
             * Callback on end rendering event
             * @property onRenderEnd
             * @default null
             * @type {Function}
             * @example
             *  this.onRenderEnd = function () {
			 *      &#x2F;&#x2F;...
			 *  }
             *&#x2F;
            this.onRenderEnd = null;

            &#x2F;&#x2F;initialize the current frame to 0
            &#x2F;&#x2F;noinspection JSUndeclaredVariable
            CGSG.currentFrame = 0;
        },

        &#x2F;**
         * Change the dimension of the canvas.
         * Does not really change the dimension of the rendering canvas container,
         *  but is used by the different computations
         * @method setCanvasDimension
         * @param {CGSGDimension} newDimension
         * *&#x2F;
        setCanvasDimension: function (newDimension) {
            CGSG.canvas.width = newDimension.width;
            CGSG.canvas.height = newDimension.height;
            CGSG.sceneGraph.setCanvasDimension(newDimension);

            &#x2F;&#x2F;Experimental
            &#x2F;*this._dblCanvas.width = newDimension.x;
             this._dblCanvas.height = newDimension.y;
             this._dblContext = this._dblCanvas.getContext(&#x27;2d&#x27;);*&#x2F;
        },

        &#x2F;**
         * Remove the nodes selected in the scene graph
         * @method deleteSelected
         *&#x2F;
        deleteSelected: function () {
            if (CGSG.selectedNodes.length &gt; 0) {
                &#x2F;&#x2F;for (var i = CGSG.selectedNodes.length - 1; i &gt;= 0; i--) {
                cgsgIterateReverse(CGSG.selectedNodes, (function(i, node) {
                    this._selectedNode = CGSG.selectedNodes[i];
                    CGSG.sceneGraph.removeNode(this._selectedNode, true);
                }).bind(this));
            }
        },

        &#x2F;**
         * Deselect all nodes
         * @public
         * @method deselectAll
         * @param {Array} excludedArray CGSGNodes not to deselect
         *&#x2F;
        deselectAll: function (excludedArray) {
            this._isDrag = false;
            this._isResizeDrag = false;
            this._resizingDirection = -1;
            &#x2F;&#x2F;CGSG.canvas.style.cursor = &#x27;auto&#x27;;
            CGSG.sceneGraph.deselectAll(excludedArray);
            this.invalidate();
        },

        &#x2F;**
         * the main rendering loop
         * @protected
         * @method render
         *&#x2F;
        render: function () {
            if (this._isRunning &amp;&amp; this._needRedraw) {
                if (this.onRenderStart !== null) {
                    var evt = new CGSGEvent(this, null);
                    CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_RENDER_START, evt);
                    &#x2F;&#x2F;this.onRenderStart();
                }

                CGSG.sceneGraph.render();

                &#x2F;&#x2F;render the drag selection box directly onto the scene graph ontop of everything else
                if (this._dragSelectStartMousePosition.length &gt; 0 &amp;&amp; this._dragSelectEndMousePosition.length &gt; 0) {

                    var p1 = this._dragSelectStartMousePosition[0];
                    var p2 = this._dragSelectEndMousePosition[0];

                    var dx = p2.x - p1.x, dy = p2.y - p1.y;

                    CGSG.sceneGraph.context.save();

                    CGSG.sceneGraph.context.scale(CGSG.displayRatio.x, CGSG.displayRatio.y);
                    CGSG.sceneGraph.context.strokeStyle = this.dragSelectStrokeColor;
                    CGSG.sceneGraph.context.fillStyle = this.dragSelectFillColor;
                    CGSG.sceneGraph.context.globalAlpha = this.dragSelectAlpha;
                    CGSG.sceneGraph.context.fillRect(p1.x, p1.y, dx, dy);
                    CGSG.sceneGraph.context.strokeRect(p1.x, p1.y, dx, dy);
                    CGSG.sceneGraph.context.restore();
                }

                if (this.onRenderEnd !== null) {
                    CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_RENDER_END, new CGSGEvent(this, null));
                    &#x2F;&#x2F;this.onRenderEnd();
                }

            }

            &#x2F;&#x2F;if (!CGSG.sceneGraph.stillHaveAnimation()) {
            &#x2F;&#x2F;	this._needRedraw = false;
            &#x2F;&#x2F;}

            this._updateFramerate();
            this._updateFramerateContainer();
        },

        &#x2F;**
         * Call this to start the update of the scene
         * @public
         * @method startPlaying
         *&#x2F;
        startPlaying: function () {
            &#x2F;&#x2F;we want the callback of the requestAnimationFrame function to be this one.
            &#x2F;&#x2F;however, the scope of &#x27;this&#x27; won&#x27;t be the same on the requestAnimationFrame function (scope = window)
            &#x2F;&#x2F; and this one (scope = this). So we bind this function to this scope
            var bindStartPlaying = this.startPlaying.bind(this);
            window.requestAnimationFrame(bindStartPlaying);
            this._isRunning = true;
            this.render();
        },

        &#x2F;**
         * Call this to stop the rendering (and so animation) update
         * @public
         * @method stopPlaying
         *&#x2F;
        stopPlaying: function () {
            window.cancelAnimationFrame(cgsgGlobalRenderingTimer);
            this._isRunning = false;
        },

        &#x2F;**
         * Inform the SceneGraph that a new render is needed
         * @public
         * @method invalidate
         *&#x2F;
        invalidate: function () {
            this._needRedraw = true;
        },

        &#x2F;**
         * Update the current framerate
         * @method _updateFramerate
         * @private
         *&#x2F;
        _updateFramerate: function () {
            if (!cgsgExist(this._fpss)) {
                this._fpss = [];
                this.currentFps = 0;
            }

            var now = new Date().getTime();
            var delta = (now - this._lastUpdate);

            if (!isNaN(CGSG.maxFramerate)) {
                while ((1000.0 &#x2F; delta) &gt; CGSG.maxFramerate) {
                    now = new Date().getTime();
                    delta = (now - this._lastUpdate);
                }
            }

            this._fpss[this.currentFps++] = 1000.0 &#x2F; delta;

            if (this.currentFps == CGSG.framerateDelay) {
                this.currentFps = 0;
                CGSG.fps = this._fpss.average();
            }

            &#x2F;*if (this._frameRatio === 0) {
                this._frameRatio = CGSG.fps;
            } else {
                this._frameRatio = ((this._frameRatio * (CGSG.currentFrame - 1)) + CGSG.fps) &#x2F; CGSG.currentFrame;
            }*&#x2F;

            this._lastUpdate = now;
        },

        &#x2F;**
         * Update the innerHTML of the HTMLElement passed as parameter of the &quot;showFPS&quot; function
         * @method _updateFramerateContainer
         * @private
         *&#x2F;
        _updateFramerateContainer: function () {
            if (this._frameContainer !== null) {
                this._frameContainer.innerHTML = Math.round(CGSG.fps)&#x2F;*.toString() + &quot; | ~&quot; + (this._frameRatio)*&#x2F;;
            }
        },

        &#x2F;**
         * @public
         * @method showFPS
         * @param {HTMLElement} elt an HTML element to receive the FPS. Can be null if you want to remove the framerate
         *&#x2F;
        showFPS: function (elt) {
            this._frameContainer = elt;
        },

        &#x2F;**
         * Set the new value for the display ratio.
         * The display ratio is used to resize all the elements on the graph to be adapted to the screen,
         * depending on the reference screen size.
         * You can compute the ratio like this: x = canvas.width&#x2F;reference.width ; y = canvas.height&#x2F;reference.height
         * @public
         * @method setDisplayRatio
         * @param {CGSGScale} newRatio a CGSGScale value
         *&#x2F;
        setDisplayRatio: function (newRatio) {
            &#x2F;&#x2F;noinspection JSUndeclaredVariable
            CGSG.displayRatio = newRatio;
            CGSG.sceneGraph.initializeGhost(CGSG.canvas.width &#x2F; CGSG.displayRatio.x,
                CGSG.canvas.height &#x2F; CGSG.displayRatio.y);
        },

        &#x2F;**
         * Detects when the mouse leaves the canvas.
         * @method onMouseOutHandler
         * @param event {MouseEvent} the event
         *&#x2F;
        onMouseOutHandler : function(event) {
            this._isPressing = false;
        },

        &#x2F;**
         * click mouse Event handler function
         * @protected
         * @method onMouseDown
         * @param {MouseEvent} event
         *&#x2F;
        onMouseDown: function (event) {
            this.onTouchStart(event);
        },

        &#x2F;**
         * touch down Event handler function
         * @protected
         * @method onTouchStart
         * @param {Event} event
         *&#x2F;
        onTouchStart: function (event) {
            this._isPressing = true;
            if (cgsgExist(this._mousePosition)) {
                this._mouseOldPosition = this._mousePosition.copy();
            }

            this._mousePosition = cgsgGetCursorPositions(event, CGSG.canvas);
            this._selectedNode = CGSG.sceneGraph.pickNode(this._mousePosition[0], null);
            if (cgsgExist(this._selectedNode) &amp;&amp; this._selectedNode.onClickStart) {
                CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_CLICK_START, new CGSGEvent(this, {nativeEvent : event, position : this._mousePosition}));
            }

            this._updateSelection(event);
        },

        &#x2F;**
         * Updates the current selection according to the given event.
         *
         * @method _updateSelection
         * @param {Event} event the event
         * @private
         *&#x2F;
        _updateSelection : function(event) {
            &#x2F;&#x2F;if a node is under the cursor, select it if it is (clickable || resizable || draggable)
            var selectable = cgsgExist(this._selectedNode) &amp;&amp;
                (this._selectedNode.isClickable || this._selectedNode.isDraggable || this._selectedNode.isResizable);

            if (selectable) {
                if (this._selectedNode.isDraggable || this._selectedNode.isResizable) {
                    &#x2F;&#x2F;if multiselection is activated
                    if (this.allowMultiSelect &amp;&amp; this._keyDownedCtrl) {
                        if (!this._selectedNode.isSelected) {
                            CGSG.sceneGraph.selectNode(this._selectedNode);
                        }
                        else {
                            CGSG.sceneGraph.deselectNode(this._selectedNode);
                        }
                    }
                    &#x2F;&#x2F;no multiselection
                    else {
                        &#x2F;&#x2F;if node not already selected
                        if (!this._selectedNode.isSelected) {
                            this.deselectAll(null);
                            CGSG.sceneGraph.selectNode(this._selectedNode);
                        }
                    }

                    this._isDrag = !this._detectResizeMode(this._mousePosition[0]);

                    &#x2F;&#x2F;ask for redraw
                    this.invalidate();
                }
            }
            &#x2F;&#x2F;else if no nodes was clicked
            else {
                this.deselectAll(null);
            }

            &#x2F;&#x2F; Check if we can start drag selection
            var canStartDragSelection = this._canStartDragSelection(event);

            &#x2F;&#x2F; if the _canStartDragSelection has not been sub classed : apply this rule :
            &#x2F;&#x2F; if no nodes were hit (that were clickable,resizeable or draggable) lets start a drag selection if we are allowed
            if (!cgsgExist(canStartDragSelection)) {
                canStartDragSelection = !selectable;
            }

            if (this.allowMultiSelect &amp;&amp; canStartDragSelection) {
                this._isDragSelect = true;
                this._dragSelectStartMousePosition = cgsgGetCursorPositions(event, CGSG.canvas);
                this._dragSelectEndMousePosition = cgsgGetCursorPositions(event, CGSG.canvas);
                this.deselectAll(null);
            }
        },

        &#x2F;**
         * This method indicates if, according to the current state of the scene, a drag selection could starts. Called
         * when a touchStart event triggered. Could be overridden to specify different behaviour.
         *
         * @method _canStartDragSelection
         * @protected
         * @param {Event} event the event
         * @return {Boolean} true if drag selection could starts, false otherwise
         *&#x2F;
        _canStartDragSelection : function(event) {
            &#x2F;&#x2F; tells the caller to use default behaviour by returning nothing (undefined)
        },

        &#x2F;**
         * Dispatch a &#x27;click&#x27; event and for any selected node which is clickable and and only if &#x27;this._isDblClick&#x27; == false.
         *
         * @method _dispatchClick
         * @param event {CGSGEvent} the event to dispatch
         * @private
         *&#x2F;
        _dispatchClick : function(event) {
            &#x2F;&#x2F;execute the action bound with the click event
            if (cgsgExist(this._selectedNode) &amp;&amp; this._selectedNode.isClickable) {
                if (!this._isDblClick &amp;&amp; cgsgExist(this._selectedNode.onClick)) {
                    event.data.node = this._selectedNode;
                    event.data.positions = this._mousePosition.copy();
                    CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_CLICK, event);
                    &#x2F;&#x2F;this._selectedNode.onClick({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                }
                &#x2F;&#x2F;deselect all node except the new _selectedNode
                if (this._selectedNode.isDraggable === false &amp;&amp; this._selectedNode.isResizable === false) {
                    this.deselectAll([this._selectedNode]);
                }
            }
        },

        &#x2F;**
         * Click on the scene
         *
         * @private
         * @method _clickOnScene
         * @param {CGSGEvent} event wrapper of MouseEvent or TouchEvent
         * @param {Boolean} mustPickNode
         *&#x2F;
        _clickOnScene: function (event, mustPickNode) {
            this._mousePosition = cgsgGetCursorPositions(event.data.nativeEvent, CGSG.canvas);

            if (this.onSceneClickStart !== null) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCENE_CLICK_START, event);
                &#x2F;&#x2F;this.onSceneClickStart({positions: this._mousePosition.copy(), event: event});
            }

            &#x2F;&#x2F;try to pick up the nodes under the cursor
            if (mustPickNode) {
                this._selectedNode = CGSG.sceneGraph.pickNode(this._mousePosition[0], function (node) {
                    return (node.isTraversable === true &amp;&amp; (node.isClickable === true || node.isDraggable === true
                        || node.isResizable === true));
                });
            }

            &#x2F;&#x2F;this._updateSelection(event);
            this._dispatchClick(event);

            if (this.onSceneClickEnd !== null) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCENE_CLICK_END, event);
                &#x2F;&#x2F;this.onSceneClickEnd({positions: this._mousePosition.copy(), event: event});
            }

            &#x2F;&#x2F;this._mouseOldPosition = this._mousePosition.copy();
        },

        &#x2F;**
         * mouse move Event handler function
         * @protected
         * @method onMouseMove
         * @param {MouseEvent} event
         *&#x2F;
        onMouseMove: function (event) {
            this._moveOnScene(event);
        },

        &#x2F;**
         * touch move Event handler function
         * @protected
         * @method onTouchMove
         * @param {Event} event
         *&#x2F;
        onTouchMove: function (event) {
            if (event.preventManipulation)
                event.preventManipulation();
            event.preventDefault();
            event.stopPropagation();
            this._moveOnScene(event);
        },

        &#x2F;**
         * @private
         * @method _moveOnScene
         * @param {Event} event MouseEvent or TouchEvent
         *&#x2F;
        _moveOnScene: function (event) {
            var mousePosition = cgsgGetCursorPositions(event, CGSG.canvas);
            var currentPosition = mousePosition[0];

            var i, nodeOffsetX, nodeOffsetY;
            this._mousePosition = mousePosition;
            var selectedNode = this._selectedNode;
            this._selectedNode = null;

            if (this._isPressing &amp;&amp; this._isDrag) {
                if (CGSG.selectedNodes.length &gt; 0) {
                    var mp = this._mousePosition[0];
                    var mop = this._mouseOldPosition[0];
                    this._offsetX = mp.x - mop.x;
                    this._offsetY = mp.y - mop.y;
                    var canMove = true;
                    for (i = CGSG.selectedNodes.length - 1; i &gt;= 0; i--) {
                        this._selectedNode = CGSG.selectedNodes[i];
                        if (this._selectedNode !== null &amp;&amp; this._selectedNode.isDraggable) {
                            this._selectedNode.isMoving = true;
                            &#x2F;&#x2F;TODO : appliquer aussi l&#x27;opposée de la rotation
                            nodeOffsetX = this._offsetX &#x2F;
                                (this._selectedNode._absoluteScale.x &#x2F; this._selectedNode.scale.x);
                            nodeOffsetY = this._offsetY &#x2F;
                                (this._selectedNode._absoluteScale.y &#x2F; this._selectedNode.scale.y);
                            &#x2F;&#x2F;check for the region constraint
                            if (this._selectedNode.regionConstraint !== null) {
                                var reg = this._selectedNode.getRegion().copy();
                                reg.position.x += nodeOffsetX;
                                reg.position.y += nodeOffsetY;
                                if (!cgsgRegionIsInRegion(reg, this._selectedNode.regionConstraint, 0)) {
                                    canMove = false;
                                }
                            }

                            if (canMove) {
                                this._selectedNode.translateWith(nodeOffsetX, nodeOffsetY);
                                if (this._selectedNode.onDrag !== null) {
                                    var evt = new CGSGEvent(this, {node: this._selectedNode, positions: this._mousePosition.copy(), nativeEvent: event});
                                    CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_DRAG, evt);
                                    &#x2F;&#x2F;this._selectedNode.onDrag({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                                }
                            }
                        }
                    }

                    this._mouseOldPosition = this._mousePosition.copy();

                    &#x2F;&#x2F; something is changing position so we better invalidate the canvas!
                    this.invalidate();
                }
            }
            else if (this._isPressing &amp;&amp; this._isResizeDrag) {
                if (CGSG.selectedNodes.length &gt; 0) {
                    var mp = this._mousePosition[0];
                    var mop = this._mouseOldPosition[0];
                    this._offsetX = mp.x - mop.x;
                    this._offsetY = mp.y - mop.y;

                    &#x2F;&#x2F;for (i = CGSG.selectedNodes.length - 1; i &gt;= 0; i--) {
                    cgsgIterateReverse(CGSG.selectedNodes, (function(i, node) {
                        this._selectedNode = node;&#x2F;&#x2F;CGSG.selectedNodes[i];

                        if (this._selectedNode.isResizable) {
                            this._selectedNode.isResizing = true;
                            &#x2F;&#x2F;TODO : appliquer aussi l&#x27;opposée de la rotation
                            nodeOffsetX = this._offsetX &#x2F; this._selectedNode._absoluteScale.x;
                            nodeOffsetY = this._offsetY &#x2F; this._selectedNode._absoluteScale.y;

                            var delta = Math.max(nodeOffsetX, nodeOffsetY);
                            if (delta == 0) {
                                delta = Math.min(nodeOffsetX, nodeOffsetY);
                            }
                            var realDimX = this._selectedNode.dimension.width *
                                this._selectedNode._absoluteScale.x;
                            var realDimY = this._selectedNode.dimension.height *
                                this._selectedNode._absoluteScale.y;
                            var d = {dW: 0, dH: 0};
                            &#x2F;&#x2F; 0  1  2
                            &#x2F;&#x2F; 3     4
                            &#x2F;&#x2F; 5  6  7
                            switch (this._resizingDirection) {
                                case 0:
                                    if (this._selectedNode.isProportionalResize) {
                                        d = this._getDeltaOnMove(delta, nodeOffsetX, nodeOffsetY, realDimX,
                                            realDimY,
                                            -1, -1);
                                        this._selectedNode.translateWith(-d.dW, -d.dH, false);
                                        this._selectedNode.resizeWith(d.dW, d.dH, false);
                                    }
                                    else {
                                        this._selectedNode.translateWith(nodeOffsetX * this._selectedNode.scale.x,
                                            nodeOffsetY * this._selectedNode.scale.y,
                                            false);
                                        this._selectedNode.resizeWith(-nodeOffsetX, -nodeOffsetY, false);
                                    }
                                    break;
                                case 1:
                                    this._selectedNode.translateWith(0, nodeOffsetY * this._selectedNode.scale.y,
                                        false);
                                    this._selectedNode.resizeWith(0, -nodeOffsetY, false);
                                    break;
                                case 2:
                                    if (this._selectedNode.isProportionalResize) {
                                        d = this._getDeltaOnMove(delta, nodeOffsetX, nodeOffsetY, realDimX,
                                            realDimY,
                                            1, -1);
                                        this._selectedNode.translateWith(0, -d.dH, false);
                                        this._selectedNode.resizeWith(d.dW, d.dH, false);
                                    }
                                    else {
                                        this._selectedNode.translateWith(0, nodeOffsetY * this._selectedNode.scale.y,
                                            false);
                                        this._selectedNode.resizeWith(nodeOffsetX, -nodeOffsetY, false);
                                    }
                                    break;
                                case 3:
                                    this._selectedNode.translateWith(nodeOffsetX * this._selectedNode.scale.x, 0,
                                        false);
                                    this._selectedNode.resizeWith(-nodeOffsetX, 0, false);
                                    break;
                                case 4:
                                    this._selectedNode.resizeWith(nodeOffsetX, 0, false);
                                    break;
                                case 5:
                                    if (this._selectedNode.isProportionalResize) {
                                        d = this._getDeltaOnMove(delta, nodeOffsetX, nodeOffsetY, realDimX,
                                            realDimY,
                                            1, -1);
                                        this._selectedNode.translateWith(d.dW, 0, false);
                                        this._selectedNode.resizeWith(-d.dW, -d.dH, false);
                                    }
                                    else {
                                        this._selectedNode.translateWith(nodeOffsetX * this._selectedNode.scale.x, 0,
                                            false);
                                        this._selectedNode.resizeWith(-nodeOffsetX, nodeOffsetY, false);
                                    }
                                    break;
                                case 6:
                                    this._selectedNode.resizeWith(0, nodeOffsetY, false);
                                    break;
                                case 7:
                                    if (this._selectedNode.isProportionalResize) {
                                        d = this._getDeltaOnMove(delta, nodeOffsetX, nodeOffsetY, realDimX,
                                            realDimY,
                                            1, 1);
                                        this._selectedNode.resizeWith(d.dW, d.dH, false);
                                    }
                                    else {
                                        this._selectedNode.resizeWith(nodeOffsetX, nodeOffsetY, false);
                                    }
                                    break;
                            }
                            this._selectedNode.computeAbsoluteMatrix(false);
                            if (this._selectedNode.onResize !== null) {
                                var evt = new CGSGEvent(this, {node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                                CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_RESIZE, evt);
                                &#x2F;&#x2F;this._selectedNode.onResize({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                            }
                        }
                    }).bind(this));
                }
                this._mouseOldPosition = this._mousePosition.copy();

                this.invalidate();
            }
            &#x2F;&#x2F; if there&#x27;s a selection, see if we grabbed one of the resize handles
            else if (CGSG.selectedNodes.length &gt; 0&#x2F;* &amp;&amp; this._isResizeDrag == false*&#x2F;) {
                if (this._detectResizeMode(this._mousePosition[0])) {
                    return;
                } else {
                    &#x2F;&#x2F; not over a selection box, return to normal
                    &#x2F;&#x2F;this._isResizeDrag = false;
                    this._resizingDirection = -1;
                    CGSG.canvas.style.cursor = &#x27;auto&#x27;;

                    &#x2F;&#x2F;ask for redraw
                    this.invalidate();
                }
            }
            &#x2F;&#x2F;if we are drag selecting
            else if (this._isDragSelect) {
                this._dragSelectEndMousePosition = this._mousePosition.copy();

                &#x2F;&#x2F;ask to redraw for the selection box
                this.invalidate();
            }

            &#x2F;&#x2F;mouse over a node ?
            if (!this._isDrag &amp;&amp; !this._isResizeDrag) {
                var n = null;
                &#x2F;&#x2F;first test the mouse over the current _nodeMouseOver. If it&#x27;s ok, no need to traverse other
                if (cgsgExist(this._nodeMouseOver)) {
                    n = this._nodeMouseOver.pickNode(this._mousePosition[0], null, CGSG.ghostContext, false, null);

                    if (n === null) {
                        this._nodeMouseOver.isMouseOver = false;
                        if (cgsgExist(this._nodeMouseOver.onMouseOut)) {
                            var evt = new CGSGEvent(this, {node: this._nodeMouseOver, positions: this._mousePosition.copy(), event: event});
                            CGSG.eventManager.dispatch(this._nodeMouseOver, cgsgEventTypes.ON_MOUSE_OUT, evt);
                            &#x2F;&#x2F;this._nodeMouseOver.onMouseOut({node: this._nodeMouseOver, positions: this._mousePosition.copy(), event: event});
                        }
                        this._nodeMouseOver = null;
                    }
                    else if (n === this._nodeMouseOver) {
                        if (cgsgExist(this._nodeMouseOver.onMouseOver)) {
                            var evt = new CGSGEvent(this, {node: this._nodeMouseOver, positions: this._mousePosition.copy(), event: event});
                            CGSG.eventManager.dispatch(this._nodeMouseOver, cgsgEventTypes.ON_MOUSE_OVER, evt);
                            &#x2F;&#x2F;this._nodeMouseOver.onMouseOver({node: this._nodeMouseOver, positions: this._mousePosition.copy(), event: event});
                        }
                    }
                }

                &#x2F;&#x2F;if the previous node under the mouse is no more under the mouse, test the other nodes
                if (n === null) {
                    if ((n = CGSG.sceneGraph.pickNode(this._mousePosition[0], function (node) {
                        return (node.onMouseEnter !== null || node.onMouseOver !== null)
                    })) !== null) {
                        n.isMouseOver = true;
                        this._nodeMouseOver = n;
                        this._nodeMouseOver.isMouseOver = true;
                        if (cgsgExist(this._nodeMouseOver.onMouseEnter)) {
                            var evt = new CGSGEvent(this, {node: this._nodeMouseOver, positions: this._mousePosition.copy(), event: event});
                            CGSG.eventManager.dispatch(this._nodeMouseOver, cgsgEventTypes.ON_MOUSE_ENTER, evt);
                            &#x2F;&#x2F;this._nodeMouseOver.onMouseEnter({node: this._nodeMouseOver, positions: this._mousePosition.copy(), event: event})
                        }
                    }
                }
            }

            this._selectedNode = selectedNode;
        },

        &#x2F;**
         * Detects if the mouse if over the handle box of a selected node.
         *
         * @method _detectResizeMode
         * @param mousePosition {CGSGPosition} the cursor position
         * @return {Boolean} true if we resize, false otherwise
         * @private
         *&#x2F;
        _detectResizeMode : function(mousePosition) {
            var selectedNode = this._selectedNode;

            cgsgIterateReverse(CGSG.selectedNodes, (function(i, node) {
                &#x2F;&#x2F;for (i = CGSG.selectedNodes.length - 1; i &gt;= 0; i--) {
                this._selectedNode = node;&#x2F;&#x2F;CGSG.selectedNodes[i];
                if (this._selectedNode.isResizable) {
                    for (var h = 0; h &lt; 8; h++) {
                        var selectionHandle = this._selectedNode.resizeHandles[h];
                        this._isResizeDrag = selectionHandle.checkIfSelected(mousePosition, CGSG.resizeHandleThreshold);

                        &#x2F;&#x2F; resize handles will always be rectangles
                        if (this._isResizeDrag) {
                            &#x2F;&#x2F; we found one!
                            this._resizingDirection = h;

                            &#x2F;&#x2F;draw the correct cursor
                            CGSG.canvas.style.cursor = this._listCursors[h];

                            &#x2F;&#x2F;if the mouse cursor is over a handle box (ie: a resize marker)
                            &#x2F;&#x2F; if (this._resizingDirection !== -1) {
                            &#x2F;&#x2F;     this._isResizeDrag = true;
                            &#x2F;&#x2F;}

                            return false;
                        }
                    }
                }
            }).bind(this));

            this._selectedNode = selectedNode;
            return this._isResizeDrag;
        },

        &#x2F;**
         * @method _getDeltaOnMove
         * @param delta
         * @param nodeOffsetX
         * @param nodeOffsetY
         * @param w
         * @param h
         * @param signeX
         * @param signeY
         * @return {Object}
         * @private
         *&#x2F;
        _getDeltaOnMove: function (delta, nodeOffsetX, nodeOffsetY, w, h, signeX, signeY) {
            var dW = nodeOffsetX, dH = nodeOffsetY;
            var ratio = 1.0;
            if (delta == nodeOffsetX) {
                ratio = (w + signeX * delta) &#x2F; w;
                dW = signeX * delta;
                dH = (ratio - 1.0) * h;
            }
            else {
                ratio = (h + signeY * delta) &#x2F; h;
                dH = signeY * delta;
                dW = (ratio - 1.0) * w;
            }

            return {dW: dW, dH: dH};
        },

        &#x2F;**
         * mouse up Event handler function
         * @protected
         * @method onMouseUp
         * @param {MouseEvent} event
         *&#x2F;
        onMouseUp: function (event) {
            this.onTouchEnd(event);
        },

        &#x2F;**
         * touch up Event handler function
         * @protected
         * @method onTouchEnd
         * @param {Event} event
         *&#x2F;
        onTouchEnd: function (event) {
            if (event.preventManipulation)
                event.preventManipulation();
            event.preventDefault();
            event.stopPropagation();

            this._isPressing = false;
            this._mouseUpCount++;

            &#x2F;&#x2F;if the touch was over a node with the onDblClick method defined, check whether it&#x27;s a dbl touch or not
            if (cgsgExist(this._selectedNode) &amp;&amp; cgsgExist(this._selectedNode.onDblClick)) {

                &#x2F;&#x2F;if the timer exists, then it&#x27;s a dbl touch
                if (this._mouseUpCount &gt; 1) {
                    clearTimeout(this._timeoutDblClick);
                    this._upAndDblClick(event);
                } else {
                    this._timeoutDblClick = setTimeout((function() {
                        this._upAndClick(event);
                    }).bind(this), this.dblTouchDelay);
                }
            }
            else {
                &#x2F;&#x2F; not a touch on a node with the onDblClick event defined,
                &#x2F;&#x2F; so it&#x27;s a single touch, just call the _clickOnScene method usually
                this._upAndClick(event);
            }
        },

        &#x2F;**
         * Creates the custom event by calling _upOnScene and then call _clickOnScene.
         *
         * @method _upAndClick
         * @param {Event} event the event
         * @private
         *&#x2F;
        _upAndClick : function(event) {
            this._mouseUpCount = 0;
            var eventData = this._upOnScene(event);
            eventData.nativeEvent = event;
            this._clickOnScene(new CGSGEvent(this, eventData), false);
        },

        &#x2F;**
         * Creates the custom event by calling _upOnScene and then call _dblClickOnScene.
         *
         * @method _upAndDblClick
         * @param {Event} event the event
         * @private
         *&#x2F;
        _upAndDblClick : function(event) {
            this._mouseUpCount = 0;
            var eventData = this._upOnScene(event);
            eventData.nativeEvent = event;
            this._dblClickOnScene(new CGSGEvent(this, eventData), false);
        },

        &#x2F;**
         * @method _upOnScene
         * @param {Event} event MouseEvent or TouchEvent
         * @return {Object} a structure indicating is the node has been moved or resize
         * @private
         *&#x2F;
        _upOnScene: function (event) {
            var selectedNode = this._selectedNode;
            var i = 0;
            var retval = {};
            retval.nativeEvent = event;

            var exist = cgsgExist(selectedNode);
            retval.hasMoved = exist &amp;&amp; selectedNode.isMoving;
            retval.hasResize = exist &amp;&amp; selectedNode.isResizing;

            &#x2F;&#x2F;if current action was to drag nodes
            if (this._isDrag) {
                cgsgIterateReverse(CGSG.selectedNodes, (function(i, node) {
                    &#x2F;&#x2F;for (i = CGSG.selectedNodes.length - 1; i &gt;= 0; i--) {
                    &#x2F;&#x2F;    this._selectedNode = CGSG.selectedNodes[i];
                    this._selectedNode = node;

                    if (this._selectedNode.isMoving) {
                        this._selectedNode.isMoving = false;
                        this._selectedNode.computeAbsoluteMatrix(true);

                        if (this._selectedNode.onDragEnd !== null) {
                            var evt = new CGSGEvent(this, {node: this._selectedNode, positions: this._mousePosition.copy(), nativeEvent: event});
                            CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_DRAG_END, evt);
                            &#x2F;&#x2F;    this._selectedNode.onDragEnd({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                        }
                    }
                    &#x2F;&#x2F;}
                }).bind(this));

                this._isDrag = false;
            }

            &#x2F;&#x2F;else if current action was to resize nodes
            else if (this._isResizeDrag) {
                cgsgIterateReverse(CGSG.selectedNodes, (function(i, node) {
                    &#x2F;&#x2F;for (i = CGSG.selectedNodes.length - 1; i &gt;= 0; i--) {
                    &#x2F;&#x2F;this._selectedNode = CGSG.selectedNodes[i];
                    this._selectedNode = node;

                    if (this._selectedNode.isResizing) {
                        this._selectedNode.isResizing = false;
                        this._selectedNode.computeAbsoluteMatrix(true);

                        if (this._selectedNode.onResizeEnd !== null) {
                            var evt = new CGSGEvent(this, {node: this._selectedNode, positions: this._mousePosition.copy(), nativeEvent: event});
                            CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_RESIZE_END, evt);
                            &#x2F;&#x2F;this._selectedNode.onResizeEnd({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                        }
                    }
                    &#x2F;&#x2F;}
                }).bind(this));

                this._isResizeDrag = false;
            }
            &#x2F;&#x2F;else if this is a drag select
            else if (this._isDragSelect) {
                this._isDragSelect = false;
                this._doDragSelect();
                this._dragSelectStartMousePosition = [];
                this._dragSelectEndMousePosition = [];

                &#x2F;&#x2F;request a re-render for the drag select rect to be killed with
                this.invalidate();
            }

            &#x2F;&#x2F;else if just up the mice of nodes
            else {
                this._selectedNode = CGSG.selectedNodes[CGSG.selectedNodes.length - 1];
                if (cgsgExist(this._selectedNode) &amp;&amp; this._selectedNode.onMouseUp !== null) {
                    var evt = new CGSGEvent(this, {node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                    CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_MOUSE_UP, evt);
                    &#x2F;&#x2F;this._selectedNode.onMouseUp({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
                }
            }

            this._resizingDirection = -1;
            this._selectedNode = selectedNode;
            return retval;
        },

        &#x2F;**
         * Select the nodes under the drag select rectangle
         * @protected
         * @method _doDragSelect
         *&#x2F;
        _doDragSelect  : function () {

            var p1 = this._dragSelectStartMousePosition[0];
            var p2 = this._dragSelectEndMousePosition[0];

            var dx = p2.x - p1.x, dy = p2.y - p1.y;

            if (dx &lt; 0) {
                dx = Math.abs(dx);
                p1.x -= dx;
            }

            if (dy &lt; 0) {
                dy = Math.abs(dy);
                p1.y -= dy;
            }

            var region = new CGSGRegion(p1.x, p1.y, dx, dy);
            var newSelections = CGSG.sceneGraph.pickNodes(region, function (node) {
                return (node.isTraversable === true &amp;&amp; (&#x2F;*node.isClickable === true ||*&#x2F; node.isDraggable === true
                    || node.isResizable === true))
            });

            for (var i = 0, len = newSelections.length; i &lt; len; ++i) {
                CGSG.sceneGraph.selectNode(newSelections[i]);
            }
        },
        &#x2F;**
         * mouse double click Event handler function
         * @protected
         * @method onMouseDblClick
         * @param {MouseEvent} event
         *&#x2F;
        onMouseDblClick: function (event) {
            &#x2F;&#x2F;this._dblClickOnScene(event);
            event.preventDefault();
            event.stopPropagation();
        },

        &#x2F;**
         * @protected
         * @method _dblClickOnScene
         * @param {CGSGEvent} event wrapping the native event
         * @param {Boolean} mustPickNode
         * @return {CGSGNode} the node that was double-clicked
         * @private
         *&#x2F;
        _dblClickOnScene: function (event, mustPickNode) {
            &#x2F;&#x2F;this._updateSelection(event);

            if (this.onSceneDblClickStart !== null) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCENE_DBL_CLICK_START, event);
                &#x2F;&#x2F;this.onSceneDblClickStart(event);
            }

            if (mustPickNode) {
                &#x2F;&#x2F;this._mousePosition = cgsgGetCursorPositions(event, CGSG.canvas);
                this._selectedNode = CGSG.sceneGraph.pickNode(this._mousePosition[0], function (node) {
                    return true;
                });
            }

            if (cgsgExist(this._selectedNode) &amp;&amp; this._selectedNode.onDblClick !== null) {
                event.data.node = this._selectedNode;
                event.data.positions = this._mousePosition.copy();
                CGSG.eventManager.dispatch(this._selectedNode, cgsgEventTypes.ON_DBL_CLICK, event);
                &#x2F;&#x2F;this._selectedNode.onDblClick({node: this._selectedNode, positions: this._mousePosition.copy(), event: event});
            }
            else if (this.onSceneDblClickEnd !== null) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCENE_DBL_CLICK_END, event);
                &#x2F;&#x2F;this.onSceneDblClickEnd({positions: this._mousePosition.copy(), event: event});
            }
            return this._selectedNode;
        },

        &#x2F;**
         * @method onKeyDownHandler
         * @protected
         * @param {KeyboardEvent} event
         * @return {Number}
         *&#x2F;
        onKeyDownHandler: function (event) {
            var keynum = (window.event) ? event.keyCode : event.which;

            switch (keynum) {
                case 17:
                    this._keyDownedCtrl = true;
                    break;
            }

            return keynum;
        },

        &#x2F;**
         * @method onKeyUpHandler
         * @protected
         * @param {KeyboardEvent} event
         * @return {Number}
         *&#x2F;
        onKeyUpHandler: function (event) {
            var keynum = (window.event) ? event.keyCode : event.which;

            switch (keynum) {
                case 17:
                    this._keyDownedCtrl = false;
                    break;
            }

            return keynum;
        }
    }
);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
