<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\node\class.node.js - cgSceneGraph</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/_GLOBAL_CONSTANTS.html">_GLOBAL_CONSTANTS</a></li>
            
                <li><a href="..&#x2F;classes/_GLOBAL_METHODS.html">_GLOBAL_METHODS</a></li>
            
                <li><a href="..&#x2F;classes/_GLOBAL_PROPERTIES.html">_GLOBAL_PROPERTIES</a></li>
            
                <li><a href="..&#x2F;classes/_UTIL_ARRAY.html">_UTIL_ARRAY</a></li>
            
                <li><a href="..&#x2F;classes/CGSGAnimationKey.html">CGSGAnimationKey</a></li>
            
                <li><a href="..&#x2F;classes/CGSGButtonMode.html">CGSGButtonMode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGColor.html">CGSGColor</a></li>
            
                <li><a href="..&#x2F;classes/CGSGDimension.html">CGSGDimension</a></li>
            
                <li><a href="..&#x2F;classes/CGSGHandleBox.html">CGSGHandleBox</a></li>
            
                <li><a href="..&#x2F;classes/CGSGHashmap.html">CGSGHashmap</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMath.html">CGSGMath</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNode.html">CGSGNode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeButton.html">CGSGNodeButton</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeCircle.html">CGSGNodeCircle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeColorPicker.html">CGSGNodeColorPicker</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeEllipse.html">CGSGNodeEllipse</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeImage.html">CGSGNodeImage</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSprite.html">CGSGNodeSprite</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSquare.html">CGSGNodeSquare</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeTabMenu.html">CGSGNodeTabMenu</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeText.html">CGSGNodeText</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeWebview.html">CGSGNodeWebview</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticle.html">CGSGParticle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleEmitter.html">CGSGParticleEmitter</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleSystem.html">CGSGParticleSystem</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPickNodeMethod.html">CGSGPickNodeMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPosition.html">CGSGPosition</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRegion.html">CGSGRegion</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRotation.html">CGSGRotation</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScale.html">CGSGScale</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScene.html">CGSGScene</a></li>
            
                <li><a href="..&#x2F;classes/CGSGSceneGraph.html">CGSGSceneGraph</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTimeline.html">CGSGTimeline</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTraverser.html">CGSGTraverser</a></li>
            
                <li><a href="..&#x2F;classes/CGSGVector2D.html">CGSGVector2D</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWEBVIEWMODE.html">CGSGWEBVIEWMODE</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWrapMode.html">CGSGWrapMode</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Animation.html">Animation</a></li>
            
                <li><a href="..&#x2F;modules/Math.html">Math</a></li>
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="..&#x2F;modules/Scene.html">Scene</a></li>
            
                <li><a href="..&#x2F;modules/Util.html">Util</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\node\class.node.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2012  Capgemini Technology Services (hereinafter “Capgemini”)
 *
 * License&#x2F;Terms of Use
 *
 * Permission is hereby granted, free of charge and for the term of intellectual property rights on the Software, to any
 * person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to use, copy, modify
 * and propagate free of charge, anywhere in the world, all or part of the Software subject to the following mandatory conditions:
 *
 *   •    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  Any failure to comply with the above shall automatically terminate the license and be construed as a breach of these
 *  Terms of Use causing significant harm to Capgemini.
 *
 *  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  Except as contained in this notice, the name of Capgemini shall not be used in advertising or otherwise to promote
 *  the use or other dealings in this Software without prior written authorization from Capgemini.
 *
 *  These Terms of Use are subject to French law.
 *&#x2F;

&quot;use strict&quot;;

&#x2F;**
 * List the methods to check the pick on a node
 * @class CGSGPickNodeMethod
 * @type {Object}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGPickNodeMethod = {
    &#x2F;**
     * @property GHOST
     *&#x2F;
    GHOST:&quot;ghost&quot;,
    &#x2F;**
     * @property REGION
     *&#x2F;
    REGION:&quot;region&quot;
};

&#x2F;**
 * Base class for a Node in the Scene Graph.
 * Each node encapsulates its position, dimension, scale and rotation, ...
 * @class CGSGNode
 * @extends Object
 * @module Node
 * @main Node
 * @constructor
 * @param {Number} x Relative position on X
 * @param {Number} y Relative position on Y
 * @param {Number} width Relative dimension
 * @param {Number} height Relative Dimension
 * @type {CGSGNode}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGNode = CGSGObject.extend(
    {
        initialize:function (x, y, width, height) {

            &#x2F;**
             * The name of this nodes. Should be unique, but no control is done.
             * @property name
             * @default &quot;&quot;
             * @type {String}
             *&#x2F;
            this.name = &quot;&quot;;
            &#x2F;**
             * Indicate whether this node is selected or not.
             * Use CGSGScene::scenegraph.selectNode(nodeToSelect) to select a node
             * @property isSelected
             * @readonly
             * @default false
             * @type {Boolean}
             *&#x2F;
            this.isSelected = false;
            &#x2F;**
             * The type of this class. Must be redefined by inherited classes
             * @property classType
             * @readonly
             * @type {String}
             *&#x2F;
            this.classType = &quot;CGSGNODE&quot;;

            &#x2F;**
             * The 8 handleboxes that will be the resize handles
             * the resize handles will be in this order:
             *  0  1  2
             *  3     4
             *  5  6  7
             * @property resizeHandles
             * @readonly
             * @type {Array}
             *&#x2F;
            this.resizeHandles = [];

            &#x2F;**
             * Level of transparency of the node.
             * @default 1.0
             * @property globalAlpha
             * @type {Number}
             *&#x2F;
            this.globalAlpha = 1.0;
            &#x2F;**
             * Indicate if the node is visible (and so selectable) or not
             * @property isVisible
             * @default true
             * @type {Boolean}
             *&#x2F;
            this.isVisible = true;

            &#x2F;**
             * If true, the node will be proportionally resized
             * @property isProportionalResize
             * @type {Boolean}
             *&#x2F;
            this.isProportionalResize = false;

            &#x2F;**
             * Define the method the detection (or &quot;pick&quot;) method will be used for this node.
             * Possible values CGSGPickNodeMethod.REGION and CGSGPickNodeMethod.GHOST.
             *
             * &lt;ul&gt;
             *     &lt;li&gt;REGION : the detection returns true if the mouse cursor is inside the bounding box of the node&lt;&#x2F;li&gt;
             *     &lt;li&gt;GHOST : the detection will use the &quot;renderGhost&quot; method of the node to achieve a more accurate detection&lt;&#x2F;li&gt;
             * &lt;&#x2F;ul&gt;
             *
             * @property pickNodeMethod
             * @default CGSGPickNodeMethod.REGION
             * @type {CGSGPickNodeMethod}
             *&#x2F;
            this.pickNodeMethod = CGSGPickNodeMethod.REGION;

            &#x2F;**
             * List of the children (empty if this nodes is a leaf)
             * @property children
             * @readonly
             * @type {Array}
             *&#x2F;
            this.children = [];

            &#x2F;**
             * The constraint region when moving the node
             * @property regionConstraint
             * @default null
             * @type {null}
             *&#x2F;
            this.regionConstraint = null;

            &#x2F;**
             * Pivot point to apply a rotation.
             * The point is a value between [0, 0] and [1, 1].
             * [0, 0] is the top left corner of the bounding box and [1, 1] the bottom right corner.
             * @property rotationCenter
             * @default null
             * @type {CGSGPosition}
             *&#x2F;
            this.rotationCenter = null;

            &#x2F;**
             * can be fulfilled by the developer to put in whatever he needs
             * @property userdata
             * @default null
             * @type {*}
             *&#x2F;
            this.userdata = null;

            &#x2F;**
             * selection attributes
             * If true, this node is clickable and so will be checked by the pickNode function
             * @property isClickable
             * @default true
             * @type {Boolean}
             *&#x2F;
            this.isClickable = true;
            &#x2F;**
             * If true, this node can be resized by the user. In that case, the dimension property will be affected, not the scale one.
             * @property isResizable
             * @default false
             * @type {Boolean}
             *&#x2F;
            this.isResizable = false;
            &#x2F;**
             * If true, the node can be dragged by the user
             * @property isDraggable
             * @default false
             * @type {Boolean}
             *&#x2F;
            this.isDraggable = false;

            &#x2F;**
             * If true, the absolute matrix will be recomputed after each movement (and so in animation).
             * Set it to false to gain performance if you don&#x27;t need to keep trace of absolute position (no need to collision, picknode, ...)
             * @property needToKeepAbsoluteMatrix
             * @default true
             * @type {Boolean}
             *&#x2F;
            this.needToKeepAbsoluteMatrix = true;

            &#x2F;**
             * Color for the line around this node when selected
             * @property selectionLineColor
             * @default &quot;#FF6890&quot;
             * @type {String}
             *&#x2F;
            this.selectionLineColor = CGSG_DEFAULT_SELECTED_STROKE_COLOR;
            &#x2F;**
             * Width for the line around this node when selected
             * @property selectionLineWidth
             * @default 2
             * @type {Number}
             *&#x2F;
            this.selectionLineWidth = CGSG_DEFAULT_SELECTED_STROKE_SIZE;
            &#x2F;**
             * Color for the handle boxes around this node when selected
             * @property selectionHandleSize
             * @default 6
             * @type {Number}
             *&#x2F;
            this.selectionHandleSize = CGSG_DEFAULT_SELECTED_RESIZEHANDLE_SIZE;
            &#x2F;**
             * Color for the handle boxes around this node when selected
             * @property selectionHandleColor
             * @default &quot;#9068FF&quot;&quot;
             * @type {String}
             *&#x2F;
            this.selectionHandleColor = CGSG_DEFAULT_SELECTED_RESIZEHANDLE_COLOR;

            &#x2F;**
             * Updated by the scene itself. Don&#x27;t update it manually.
             * True if the mice is over the node, false otherwise
             * @property isMouseOver
             * @readonly
             * @type {Boolean}
             *&#x2F;
            this.isMouseOver = false;
            &#x2F;**
             * Updated by the scene itself. Don&#x27;t update it manually.
             * True if the node is being moved manually, false otherwise
             * @property isMoving
             * @readonly
             * @type {Boolean}
             *&#x2F;
            this.isMoving = false;
            &#x2F;**
             * Updated by the scene itself. Don&#x27;t update it manually.
             * True if the node is being resized manually, false otherwise
             * @property isResizing
             * @readonly
             * @type {Boolean}
             *&#x2F;
            this.isResizing = false;

            &#x2F;**
             * ID for the node. Should be filled by the developer. The framework will never use it.
             * @property _id
             * @type {Number}
             * @private
             *&#x2F;
            this._id = 0;
            &#x2F;**
             * parent of this node
             * @property _parentNode
             * @type {CGSGNode}
             * @private
             *&#x2F;
            this._parentNode = null;

            &#x2F;**
             * Relative position of this nodes on the canvas container, relatively to the position of its parent node.
             * Never use it to move the node, use translateBy&#x2F;translateWith&#x2F;translateTo instead
             * @readonly
             * @property position
             * @default CGSGPosition(0, 0)
             * @type {CGSGPosition}
             *&#x2F;
            this.position = new CGSGPosition(0, 0);
            &#x2F;**
             * Absolute position of this nodes on the canvas container. Generated value. Don&#x27;t modify it manually
             * Never use it to move the node, use translateBy&#x2F;translateWith&#x2F;translateTo instead
             * @readonly
             * @property _absolutePosition
             * @private
             * @type {CGSGPosition}
             *&#x2F;
            this._absolutePosition = new CGSGPosition(0, 0);
            &#x2F;**
             * Dimension of this nodes on the canvas container
             * Never use it to resize the node, use resizeBy&#x2F;resizeWith&#x2F;resizeTo instead
             * @readonly
             * @property dimension
             * @default CGSGDimension(0, 0)
             * @type {CGSGDimension}
             *&#x2F;
            this.dimension = new CGSGDimension(0, 0);
            &#x2F;**
             * Relative scale of this nodes on the canvas container, relatively to the scale of its parent node.
             * Never use it to scale or resize the node, use scaleBy&#x2F;scaleWith&#x2F;scaleTo instead
             * @readonly
             * @property scale
             * @default CGSGScale(1, 1)
             * @type {CGSGScale}
             *&#x2F;
            this.scale = new CGSGScale(1, 1);
            &#x2F;**
             * Absolute scale of this nodes on the canvas container. Generated value. Don&#x27;t modify it manually
             * Never use it to scale the node, use scaleBy&#x2F;scaleWith&#x2F;scaleTo instead
             * @readonly
             * @property _absoluteScale
             * @private
             * @type {CGSGScale}
             *&#x2F;
            this._absoluteScale = new CGSGScale(1, 1);
            &#x2F;**
             * Relative rotation of this nodes on the canvas container, relatively to the rotation of its parent node.
             * Never use it to rotate or resize the node, use rotateBy&#x2F;rotateWith&#x2F;rotateTo instead
             * @readonly
             * @property rotation
             * @default CGSGRotation(0)
             * @type {CGSGRotation}
             *&#x2F;
            this.rotation = new CGSGRotation(0);
            &#x2F;**
             * Absolute rotation of this nodes on the canvas container. Generated value. Don&#x27;t modify it manually
             * Never use it to rotate or resize the node, use rotateBy&#x2F;rotateWith&#x2F;rotateTo instead
             * @readonly
             * @private
             * @property _absoluteRotation
             * @type {CGSGRotation}
             *&#x2F;
            this._absoluteRotation = new CGSGRotation(0);

            &#x2F;**
             * @property _isDrag
             * @type {Boolean}
             * @private
             *&#x2F;
            this._isDrag = false;

            &#x2F;&#x2F;this.selectableZone =
            &#x2F;&#x2F;new CGSGRegion(this.position.x, this.position.y, this.dimension.width, this.dimension.height);

            &#x2F;**
             * true if this node is traversable (recursively) (ie : by the picknode, a traverser, ...)
             * @property isTraversable
             * @type {Boolean}
             *&#x2F;
            this.isTraversable = true;

            &#x2F;&#x2F;initialize the position and dimension
            this.translateTo(x, y, true);
            this.resizeTo(width, height);

            &#x2F;&#x2F; initialize the selection handleBoxes
            for (var i = 0; i &lt; 8; i++) {
                var handleBox = new CGSGHandleBox(this, this.selectionHandleSize, this.selectionHandleColor, 0, 0);
                this.resizeHandles.push(handleBox);
            }

            &#x2F;**
             * Callback on mouse over the node
             * @property onMouseOver
             * @default null
             * @type {function}
             *
             * @example
             *  this.onMouseOver = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onMouseOver = null;
            &#x2F;**
             * Callback on mouse enter on the node
             * @property onMouseEnter
             * @default null
             * @type {function}
             *
             * @example
             *  this.onMouseEnter = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onMouseEnter = null;
            &#x2F;**
             * Callback on mouse out
             * @property onMouseOut
             * @default null
             * @type {function}
             *
             * @example
             *  this.onMouseOut = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onMouseOut = null;
            &#x2F;**
             * Callback on mouse up
             * @property onMouseUp
             * @default null
             * @type {function}
             *
             * @example
             *  this.onMouseUp = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onMouseUp = null;
            &#x2F;**
             * Callback on mouse or touch click
             * @property onClick
             * @default null
             * @type {function}
             *
             * @example
             *  this.onClick = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onClick = null;
            &#x2F;**
             * Callback on mouse or touch double click
             * @property onDblClick
             * @default null
             * @type {function}
             *
             * @example
             *  this.onDblClick = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onDblClick = null;
            &#x2F;**
             * Callback on drag this node
             * @property onDrag
             * @default null
             * @type {function}
             *
             * @example
             *  this.onDrag = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onDrag = null;
            &#x2F;**
             * Callback on end of drag this node
             * @property onDragEnd
             * @default null
             * @type {function}
             *
             * @example
             *  this.onDragEnd = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onDragEnd = null;
            &#x2F;**
             * Callback on resize this node
             * @property onResize
             * @default null
             * @type {function}
             *
             * @example
             *  this.onResize = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onResize = null;
            &#x2F;**
             * Callback on end resize this node
             * @property onResizeEnd
             * @default null
             * @type {function}
             *
             * @example
             *  this.onResizeEnd = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onResizeEnd = null;
            &#x2F;**
             * Callback on select this node
             * @property onSelect
             * @default null
             * @type {function}
             *
             * @example
             *  this.onSelect = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onSelect = null;
            &#x2F;**
             * Callback on deselect this node
             * @property onDeselect
             * @default null
             * @type {function}
             *
             * @example
             *  this.onDeselect = function (event) {
			 *      event.node; &#x2F;&#x2F;CGSGNode
			 *      event.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.event; &#x2F;&#x2F;Event
			 *  }
             *&#x2F;
            this.onDeselect = null;

            this.computeAbsoluteMatrix(true);
        },

        &#x2F;**
         * return the relative region of this node
         * @public
         * @method getRegion
         * @return {CGSGRegion}
         *&#x2F;
        getRegion:function () {
            return new CGSGRegion(this.position.x, this.position.y, this.getWidth(), this.getHeight());
        },

        &#x2F;**
         * return the absolute region of this node
         * @public
         * @method getAbsoluteRegion
         * @return {CGSGRegion}
         *&#x2F;
        getAbsoluteRegion:function () {
            return new CGSGRegion(this.getAbsoluteLeft(), this.getAbsoluteTop(), this.getAbsoluteWidth(),
                this.getAbsoluteHeight());
        },

        &#x2F;&#x2F;&#x2F;&#x2F; RENDERING MANIPULATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        &#x2F;**
         * Wipes the canvas context
         * @method _clearContext
         * @param context
         * @param canvasWidth
         * @param canvasHeight
         * @private
         *&#x2F;
        _clearContext:function (context, canvasWidth, canvasHeight) {
            context.clearRect(0, 0, canvasWidth, canvasHeight);
        },

        &#x2F;**
         * Empty rendering function. Must be overrided by the inherited classes
         * @method render
         * @param {CanvasRenderingContext2D} context the context into render the node
         * *&#x2F;
        render:function (context) {
            &#x2F;&#x2F;save current state
            this.beforeRender(context);

            &#x2F;&#x2F;restore state
            this.afterRender(context);
        },

        &#x2F;**
         * Empty ghost rendering function.
         * Render here your custom nodes with a single color (cgsgGhostColor).
         * This will be used by the SceneGraph to know if the mouse cursor is over this nodes.
         *
         * @method renderGhost
         * @param ghostContext The context for the ghost rendering
         *&#x2F;
        renderGhost:function (ghostContext) {
            &#x2F;&#x2F;save current state
            this.beforeRenderGhost(ghostContext);

            &#x2F;&#x2F;restore state
            this.afterRenderGhost(ghostContext);
        },

        &#x2F;**
         * Render the selection box and handle boxes around the bounding box of this node when selected
         * @protected
         * @method renderSelected
         * @param {CanvasRenderingContext2D} context the context into render the node
         * *&#x2F;
        renderSelected:function (context) {
            this._absolutePosition = this.getAbsolutePosition();
            this._absoluteScale = this.getAbsoluteScale();

            context.strokeStyle = this.selectionLineColor;

            context.lineWidth = this.selectionLineWidth &#x2F; this._absoluteScale.y;
            context.beginPath();
            &#x2F;&#x2F;top line
            context.moveTo(0, 0);
            context.lineTo(this.dimension.width, 0);
            &#x2F;&#x2F;bottom line
            context.moveTo(0, this.dimension.height);
            context.lineTo(this.dimension.width, this.dimension.height);
            context.stroke();
            context.closePath();

            context.lineWidth = this.selectionLineWidth &#x2F; this._absoluteScale.x;
            context.beginPath();
            &#x2F;&#x2F;left line
            context.moveTo(0, 0);
            context.lineTo(0, this.dimension.height);
            &#x2F;&#x2F;right line
            context.moveTo(this.dimension.width, 0);
            context.lineTo(this.dimension.width, this.dimension.height);
            context.stroke();
            context.closePath();

            &#x2F;&#x2F;draw the resize handles
            if (this.isResizable) {
                &#x2F;&#x2F; draw the handle boxes
                var halfX = this.selectionHandleSize &#x2F; (2 * this._absoluteScale.x);
                var halfY = this.selectionHandleSize &#x2F; (2 * this._absoluteScale.y);

                &#x2F;&#x2F; 0  1  2
                &#x2F;&#x2F; 3     4
                &#x2F;&#x2F; 5  6  7

                &#x2F;&#x2F; top left, middle, right
                this.resizeHandles[0].translateTo(-halfX, -halfY);
                this.resizeHandles[1].translateTo(this.dimension.width &#x2F; 2 - halfX, -halfY);
                this.resizeHandles[2].translateTo(this.dimension.width - halfX, -halfY);

                &#x2F;&#x2F; middle left
                this.resizeHandles[3].translateTo(-halfX, this.dimension.height &#x2F; 2 - halfY);

                &#x2F;&#x2F; middle right
                this.resizeHandles[4].translateTo(this.dimension.width - halfX,
                    this.dimension.height &#x2F; 2 - halfY);

                &#x2F;&#x2F; bottom left, middle, right
                this.resizeHandles[6].translateTo(this.dimension.width &#x2F; 2 - halfX,
                    this.dimension.height - halfY);
                this.resizeHandles[5].translateTo(-halfX, this.dimension.height - halfY);
                this.resizeHandles[7].translateTo(this.dimension.width - halfX,
                    this.dimension.height - halfY);

                for (var i = 0; i &lt; 8; i++) {
                    this.resizeHandles[i].size = this.selectionHandleSize;
                    this.resizeHandles[i].color = this.selectionHandleColor;
                    this.resizeHandles[i].render(context);
                }
            }
        },

        &#x2F;**
         * Must be called before to start the rendering of the nodes
         * @protected
         * @method beforeRender
         * @param {CanvasRenderingContext2D} context the context into render the nodes
         * *&#x2F;
        beforeRender:function (context) {
            &#x2F;&#x2F;first save the current context state
            context.save();

            &#x2F;&#x2F;move the context to the nodes&#x27;s relative position
            context.translate(this.position.x, this.position.y);

            &#x2F;&#x2F; translate context to center of canvas
            if (cgsgExist(this.rotationCenter)) {
                context.translate(this.dimension.width * this.rotationCenter.x,
                    this.dimension.height * this.rotationCenter.y);
                context.rotate(this.rotation.angle);
                context.translate(-this.dimension.width * this.rotationCenter.x,
                    -this.dimension.height * this.rotationCenter.y);
            }
            else {
                context.rotate(this.rotation.angle);
            }
            context.scale(this.scale.x, this.scale.y);
        },

        &#x2F;**
         * Must be called after a render
         * @protected
         * @method afterRender
         * @param {CanvasRenderingContext2D} context the context into render the nodes
         * *&#x2F;
        afterRender:function (context) {
            &#x2F;&#x2F;render all children
            if (!this.isALeaf()) {
                &#x2F;&#x2F;draw children
                for (var i = 0, len = this.children.length; i &lt; len; ++i) {
                    var childNode = this.children[i];
                    if (childNode.isVisible) {
                        childNode.render(context);
                    }
                }
            }

            &#x2F;&#x2F;restore the context state
            context.restore();
        },

        &#x2F;**
         * Must be called before begin to render the nodes in GHOST mode
         * @protected
         * @method beforeRenderGhost
         * @param {CanvasRenderingContext2D} context the context into render the nodes
         *&#x2F;
        beforeRenderGhost:function (context) {
            &#x2F;&#x2F;first save the current context state
            context.save();
            &#x2F;&#x2F;move the context to the nodes&#x27;s relative position
            context.translate(this._absolutePosition.x, this._absolutePosition.y);
            context.rotate(this._absoluteRotation.angle);
            context.scale(this._absoluteScale.x, this._absoluteScale.y);
        },

        &#x2F;**
         * Must be called before begin to render
         * @protected
         * @method afterRenderGhost
         * @param {CanvasRenderingContext2D} context the context into render the nodes
         * *&#x2F;
        afterRenderGhost:function (context) {
            &#x2F;&#x2F;restore the context state
            context.restore();
        },

        &#x2F;**
         * Mark this nodes as selected
         * @method setSelected
         * @param {Boolean} isSelected
         * *&#x2F;
        setSelected:function (isSelected) {
            this.isSelected = isSelected;
            this._isDrag = true;

            if (isSelected &amp;&amp; this.onSelect !== null) {
                this.onSelect({node:this});
            }
            else if (this.onDeselect !== null) {
                this.onDeselect({node:this});
            }
        },

        &#x2F;**
         * return this if this nodes is under the mice cursor
         * Can be overrided by inherited klass to optimize this perform.
         * This default function used the ghost rendering method
         * @protected
         * @method detectSelection
         * @param {CGSGPosition} mousePosition A CGSGPosition object
         * @param {CanvasRenderingContext2D} ghostContext
         * @param {CGSGScale} absoluteScale
         *&#x2F;
        detectSelection:function (mousePosition, ghostContext, absoluteScale) {

            if (this.pickNodeMethod == CGSGPickNodeMethod.REGION) {
                if (mousePosition.x &gt;= this._absolutePosition.x
                    &amp;&amp; mousePosition.x &lt;= this._absolutePosition.x + this.getWidth() * absoluteScale.x
                    &amp;&amp; mousePosition.y &gt;= this._absolutePosition.y
                    &amp;&amp; mousePosition.y &lt;= this._absolutePosition.y + this.getHeight() * absoluteScale.y
                    ) {
                    return this;
                }
            }
            else &#x2F;*if (this.pickNodeMethod == CGSGPickNodeMethod.GHOST)*&#x2F; {
                &#x2F;&#x2F; draw shape onto ghost context
                this.renderGhost(ghostContext);

                &#x2F;&#x2F; get image data at the mouse x,y pixel
                var imageData = ghostContext.getImageData(mousePosition.x, mousePosition.y, 1, 1);

                cgsgClearContext(ghostContext);

                &#x2F;&#x2F; if the mouse pixel exists, select this nodes
                if (imageData.data[0] != 0 || imageData.data[1] != 0 || imageData.data[2] != 0) {
                    return this;
                }
            }

            return null;
        },

        &#x2F;**
         * Check if this nodes is under the cursor position.
         * @public
         * @method pickNode
         * @param {CGSGPosition} mousePosition position of the mouse on the canvas
         * @param {CGSGScale} absoluteScale a CGSGScale absolute relativeScale of all parents
         * @param {CanvasRenderingContext2D} ghostContext a copy of the canvas context
         * @param {Boolean} recursively if false, don&#x27;t traverse the children of this nodes
         * @param {Function} condition Condition to be picked
         * ie: &quot;color==&#x27;yellow&#x27;&quot; or &quot;classType==&#x27;CGSGNodeImage&#x27; &amp;&amp; this.globalAlpha&gt;0.5&quot;
         * *&#x2F;
        pickNode:function (mousePosition, absoluteScale, ghostContext, recursively, condition) {
            var selectedNode = null;

            var childAbsoluteScale = null;
            if (cgsgExist(absoluteScale)) {
                childAbsoluteScale = absoluteScale.copy();
                childAbsoluteScale.multiply(this.scale);
            }
            else {
                childAbsoluteScale = this.getAbsoluteScale();
            }

            if (this.isTraversable &amp;&amp; (this.isClickable || this.isResizable || this.isDraggable)) {
                if (!cgsgExist(condition) || condition(this) === true) {
                    this.computeAbsoluteMatrix(false);
                    selectedNode =
                        this.detectSelection(mousePosition, ghostContext, childAbsoluteScale);
                }
            }

            &#x2F;&#x2F;traverse the children if asked
            if (this.isTraversable &amp;&amp; recursively &amp;&amp; !this.isALeaf()) {
                for (var i = this.children.length - 1; i &gt;= 0; --i) {
                    var childNode = this.children[i];
                    var selectedChild = childNode.pickNode(mousePosition,
                        childAbsoluteScale, ghostContext,
                        recursively, condition);
                    if (selectedChild !== null &amp;&amp; selectedChild !== undefined) {
                        selectedNode = selectedChild;
                        break;
                    }
                }

                childAbsoluteScale = null;
            }

            return selectedNode;
        },

        &#x2F;**
         * Return true if this nodes has no child
         * @method isALeaf
         * *&#x2F;
        isALeaf:function () {
            return this.children.length &lt;= 0;
        },

        &#x2F;&#x2F;&#x2F;&#x2F; TRANSFORMATION MANIPULATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        &#x2F;**
         * Replace current relative position by this new one
         * @method translateTo
         * @param {Number} newRelativeX
         * @param {Number} newRelativeY
         * @param {Boolean} computeAbosluteValue (default: true)
         *&#x2F;
        translateTo:function (newRelativeX, newRelativeY, computeAbosluteValue) {
            this.position.translateTo(newRelativeX, newRelativeY);
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absolutePosition = this.getAbsolutePosition();
            }
        },

        &#x2F;**
         * Add new coordinate to the current relative one
         * @method translateWith
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        translateWith:function (x, y, computeAbosluteValue) {
            this.position.translateWith(x, y);
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absolutePosition = this.getAbsolutePosition();
            }
        },

        &#x2F;**
         * Add new coordinate to the current relative one
         * @method translateBy
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        translateBy:function (x, y, computeAbosluteValue) {
            this.position.translateBy(x, y);
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absolutePosition = this.getAbsolutePosition();
            }
        },

        &#x2F;**
         * Replace current dimension by these new ones
         * @method resizeTo
         * @param {Number} newWidth
         * @param {Number} newHeight
         * *&#x2F;
        resizeTo:function (newWidth, newHeight) {
            this.dimension.resizeTo(newWidth, newHeight);
        },

        &#x2F;**
         * Multiply current dimension by these new ones
         * @method resizeTBy
         * @param {Number} widthFactor
         * @param {Number} heightFactor
         * *&#x2F;
        resizeBy:function (widthFactor, heightFactor) {
            this.dimension.resizeBy(widthFactor, heightFactor);
        },

        &#x2F;**
         * Increase&#x2F;decrease current dimension with adding values
         * @method resizeWith
         * @param {Number} width
         * @param {Number} height
         * *&#x2F;
        resizeWith:function (width, height) {
            this.dimension.resizeWith(width, height);
        },

        &#x2F;**
         * Replace current relative relativeScale by this new one
         * @method scaleTo
         * @param {Number} scaleX
         * @param {Number} scaleY
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        scaleTo:function (scaleX, scaleY, computeAbosluteValue) {
            this.scale.x = scaleX;
            this.scale.y = scaleY;
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absoluteScale = this.getAbsoluteScale();
            }
        },

        &#x2F;**
         * Multiply this relativeScale factor by the current relative relativeScale
         * @method scaleBy
         * @param {Number} scaleFactorX
         * @param {Number} scaleFactorY
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        scaleBy:function (scaleFactorX, scaleFactorY, computeAbosluteValue) {
            this.scale.x *= scaleFactorX;
            this.scale.y *= scaleFactorY;
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absoluteScale = this.getAbsoluteScale();
            }
        },

        &#x2F;**
         * Add to the current relative Scale
         * @method scaleWith
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        scaleWith:function (x, y, computeAbosluteValue) {
            this.scale.x += x;
            this.scale.y += y;
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absoluteScale = this.getAbsoluteScale();
            }
        },

        &#x2F;**
         * Replace current relative relativeRotation by this new oneScale
         * @method rotateTo
         * @param {Number} newAngle
         * @param {Boolean} computeAbosluteValue (default: true)
         *
         * *&#x2F;
        rotateTo:function (newAngle, computeAbosluteValue) {
            this.rotation.rotateTo(newAngle);
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absoluteRotation = this.getAbsoluteRotation();
            }
        },

        &#x2F;**
         * Multiply this relativeScale factor by the current relative relativeScale
         * @method rotateBy
         * @param {Number} rotateFactor
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        rotateBy:function (rotateFactor, computeAbosluteValue) {
            this.rotation.rotateBy(rotateFactor);
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absoluteRotation = this.getAbsoluteRotation();
            }
        },

        &#x2F;**
         * Add this angle to the current relative relativeRotation
         * @method rotateWith
         * @param {Number} angle
         * @param {Boolean} computeAbosluteValue (default: true)
         * *&#x2F;
        rotateWith:function (angle, computeAbosluteValue) {
            this.rotation.rotateWith(angle);
            if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbosluteValue !== false) {
                this._absoluteRotation = this.getAbsoluteRotation();
            }
        },

        &#x2F;&#x2F;&#x2F;&#x2F; CHILDREN MANIPULATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        &#x2F;**
         * Add a new nodes into this one, at the end of the list
         * @method addChild
         * @param {CGSGNode} newNode the nodes to add as a child
         * *&#x2F;
        addChild:function (newNode) {
            newNode._parentNode = this;
            this.children[this.children.length] = newNode;
        },

        &#x2F;**
         * Add a new nodes at a particular index in the list of children.
         * If the index is too large, the nodes will be inserted at the end of the list
         * @method addChildAt
         * @param {CGSGNode} newNode the nodes to insert as a child
         * @param {Number} index the position of the new child in the list
         * *&#x2F;
        addChildAt:function (newNode, index) {
            if (index &gt; this.children.length) {
                index = this.children.length;
            }

            for (var i = this.children.length; i &gt;= index; --i) {
                this.children[i] = this.children[i - 1];
            }

            newNode._parentNode = this;
            this.children[index] = newNode;
        },

        &#x2F;**
         * Remove the child passed in parameter and delete it
         * @method removeChild
         * @param {CGSGNode} node the nodes to remove
         * @param {Boolean} searchRecursively if true, search the nodes on all the tree from this nodes
         * @return {Boolean} true if the child was correctly removed or false if the nodes was not found.
         * *&#x2F;
        removeChild:function (node, searchRecursively) {
            var index = this.children.indexOf(node);

            if (index &gt;= 0) {
                this.children.without(node);
                node.free();
                return true;
            }

            if (searchRecursively) {
                for (var i = 0, len = this.children.length; i &lt; len; ++i) {
                    var childNode = this.children[i];
                    if (childNode.removeChild(node, true)) {
                        return true;
                    }
                }
            }

            return false;
        },

        &#x2F;**
         * remove all children, delete them and reset the current parameters
         * @method removeAll
         * *&#x2F;
        removeAll:function () {
            &#x2F;*for (var i = this.children.length; i &gt;=0; --i) {
             var childNode = this.children[i];
             childNode.removeAll();
             this.removeChild(childNode, true);
             }*&#x2F;

            this.free();
        },

        &#x2F;**
         * Detach the nodes in index &#x27;index&#x27; without delete it. So it&#x27;s not a child anymore
         * @method detachChildAt
         * @param {Number} index
         *&#x2F;
        detachChildAt:function (index) {
            if (index &gt;= 0 &amp;&amp; index &lt; this.children.length) {
                this.detachChild(this.children[index]);
            }
        },

        &#x2F;**
         * Detach the nodes without delete it. So it&#x27;s not a child anymore
         * @method detachChild
         * @param {CGSGNode} childNode
         *&#x2F;
        detachChild:function (childNode) {
            if (cgsgExist(childNode)) {
                childNode._parentNode = null;
                &#x2F;*this.children = *&#x2F;
                this.children.without(childNode);
            }
        },

        &#x2F;**
         * Execute&#x2F;Eval the script passed in parameter in &quot;this&quot; scope.
         * Used to set new value to an attribute of a node
         * @method evalSet
         * @param {String} attribute The attribute to be changed
         * @param {*} value The new value for the attribute
         *
         * @example node.evalSet(&quot;position.y&quot;, 12);
         *&#x2F;
        evalSet:function (attribute, value) {
            &#x2F;&#x2F;check for common properties to optimize performances
            if (attribute == &quot;position.x&quot;) {
                this.translateTo(value, this.position.y, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;position.y&quot;) {
                this.translateTo(this.position.x, value, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;dimension.width&quot;) {
                this.resizeTo(value, this.dimension.height, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;dimension.height&quot;) {
                this.resizeTo(this.dimension.width, value, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;scale.x&quot;) {
                this.scaleTo(value, this.scale.y, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;scale.y&quot;) {
                this.scaleTo(this.scale.x, value, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;rotation&quot; || attribute == &quot;rotation.angle&quot;) {
                this.rotateTo(value, this.needToKeepAbsoluteMatrix);
            }
            else if (attribute == &quot;globalAlpha&quot;) {
                this.globalAlpha = value;
            }
            else if (attribute == &quot;isVisible&quot;) {
                this.isVisible = value;
            }
            else if (attribute == &quot;rotationCenter.x&quot;) {
                this.rotationCenter.x = value;
            }
            else if (attribute == &quot;rotationCenter.y&quot;) {
                this.rotationCenter.y = value;
            }
            else if (attribute == &quot;color.r&quot;) {
                var rgb = CGSGColor.hex2rgb(this.color);
                this.color = CGSGColor.rgb2hex(value, rgb.g, rgb.b);
            }
            else if (attribute == &quot;color.g&quot;) {
                var rgb = CGSGColor.hex2rgb(this.color);
                this.color = CGSGColor.rgb2hex(rgb.r, value, rgb.b);
            }
            else if (attribute == &quot;color.b&quot;) {
                var rgb = CGSGColor.hex2rgb(this.color);
                this.color = CGSGColor.rgb2hex(rgb.r, rgb.g, value);
            }

            &#x2F;&#x2F;generic property
            else  {
                eval(&quot;this.&quot; + attribute + &quot;=&quot; + value);
            }


            &#x2F;*if (this.needToKeepAbsoluteMatrix) {
                if (attribute.indexOf(&quot;position&quot;) == 0) {
                    this._absolutePosition = this.getAbsolutePosition();
                }
                else if (attribute.indexOf(&quot;rotation&quot;) == 0) {
                    this._absoluteRotation = this.getAbsoluteRotation();
                }
                else if (attribute.indexOf(&quot;scale&quot;) == 0) {
                    this._absoluteScale = this.getAbsoluteScale();
                }
            }*&#x2F;
        },

        &#x2F;**
         * Set the region inside which one this node ca be placed an can move
         * @public
         * @method setRegionConstraint
         * @param {CGSGRegion} region a CGSGRegion relatively to this parent region. Can be null.
         *&#x2F;
        setRegionConstraint:function (region) {
            this.regionConstraint = region;
        },

        &#x2F;**
         * @public
         * @method getAbsolutePosition
         * @return {CGSGPosition} the absolute positions of this node
         *&#x2F;
        getAbsolutePosition:function () {
            var n = this;
            var translation = this.position.copy();
            while (n._parentNode !== null) {
                translation.multiply(n._parentNode.scale);
                n = n._parentNode;
            }

            if (this._parentNode !== null) {
                translation.add(this._parentNode.getAbsolutePosition());
            }

            return translation;
        },

        &#x2F;**
         * @public
         * @method getAbsoluteScale
         * @return {CGSGScale} the absolute scale of this node
         *&#x2F;
        getAbsoluteScale:function () {
            var n = this;
            var s = this.scale.copy();
            while (n._parentNode !== null) {
                s.multiply(n._parentNode.scale);
                n = n._parentNode;
            }
            return s;
        },

        &#x2F;**
         * @public
         * @method getAbsoluteRotation
         * @return {CGSGRotation} the absolute rotation of this node
         *&#x2F;
        getAbsoluteRotation:function () {
            var n = this;
            var r = this.rotation.copy();
            while (n._parentNode !== null) {
                r.add(n._parentNode.rotation.angle);
                n = n._parentNode;
            }
            return r;
        },

        &#x2F;**
         * Compute the absolute position, rotation and scale in the canvas container
         * @public
         * @method computeAbsoluteMatrix
         * @param {Boolean} recursive if !== false, compute recursively
         * *&#x2F;
        computeAbsoluteMatrix:function (recursive) {
            this._absolutePosition = this.getAbsolutePosition();
            this._absoluteScale = this.getAbsoluteScale();
            this._absoluteRotation = this.getAbsoluteRotation();

            if (recursive !== false) {
                for (var c = 0; c &lt; this.children.length; c++) {
                    if (cgsgExist(this.children[c])) {
                        this.children[c].computeAbsoluteMatrix(recursive);
                    }
                }
            }
        },

        &#x2F;**
         * @method getAbsoluteLeft
         * @return {Number}
         *&#x2F;
        getAbsoluteLeft:function () {
            return this._absolutePosition.x;
        },
        &#x2F;**
         * @method getAbsoluteRight
         * @return {Number}
         *&#x2F;
        getAbsoluteRight:function () {
            return this._absolutePosition.x + this.getAbsoluteWidth();
        },
        &#x2F;**
         * @method getAbsoluteTop
         * @return {Number}
         *&#x2F;
        getAbsoluteTop:function () {
            return this._absolutePosition.y;
        },
        &#x2F;**
         * @method getAbsoluteBottom
         * @return {Number}
         *&#x2F;
        getAbsoluteBottom:function () {
            return this._absolutePosition.y + this.getAbsoluteHeight();
        },
        &#x2F;**
         * @method getAbsoluteWidth
         * @return {Number}
         *&#x2F;
        getAbsoluteWidth:function () {
            return this.getWidth() * this._absoluteScale.x;
        },
        &#x2F;**
         * @method getAbsoluteHeight
         * @return {Number}
         *&#x2F;
        getAbsoluteHeight:function () {
            return this.getHeight() * this._absoluteScale.y;
        },
        &#x2F;**
         * @method getWidth
         * @return {Number}
         *&#x2F;
        getWidth:function () {
            return this.dimension.width;
        },
        &#x2F;**
         * @method getHeight
         * @return {Number}
         *&#x2F;
        getHeight:function () {
            return this.dimension.height;
        },

        &#x2F;**
         * @public
         * @method isColliding
         * @return {Boolean} true if the 2 nodes are colliding. They are colliding if the distance between them is minus than the threshold parameter
         * @param {CGSGNode} node a CGSGNode
         * @param {Number} threshold space between the 2 nodes before considering they are colliding
         *&#x2F;
        isColliding:function (node, threshold) {
            if (threshold === null) {
                threshold = 0;
            }
            var nodeRight = node.getAbsoluteRight();
            var nodeBottom = node.getAbsoluteBottom();

            if ((this.getAbsoluteLeft() &lt;= nodeRight + threshold &amp;&amp;
                this.getAbsoluteRight() &gt;= node.getAbsoluteLeft() - threshold) ||
                (this.getAbsoluteRight() &gt;= node.getAbsoluteLeft() - threshold &amp;&amp;
                    this.getAbsoluteLeft() &lt;= nodeRight + threshold)) {

                if (this.getAbsoluteTop() &lt;= nodeBottom + threshold &amp;&amp;
                    this.getAbsoluteBottom() &gt;= node.getAbsoluteTop() - threshold) {
                    return true;
                }
            }

            return false;
        },

        &#x2F;**
         * @public
         * @method getListOfCollidingBrothers
         * @return {Array} a Array of nodes this one is colliding with (can be empty)
         * @param {Number} threshold space between the 2 nodes before considering they are colliding
         *&#x2F;
        getListOfCollidingBrothers:function (threshold) {
            var listOfCollidingNodes = [];
            var brother = null;
            for (var n = 0; n &lt; this._parentNode.children.length; n++) {
                brother = this._parentNode.children[n];
                if (brother !== this &amp;&amp; this.isColliding(brother, threshold)) {
                    listOfCollidingNodes.push(brother);
                }
            }

            return listOfCollidingNodes;
        },

        &#x2F;**
         * @public
         * @method isCollidingABrother
         * @param {Number} threshold space between the 2 nodes before considering they are colliding
         * @return {Boolean} true if this node is colliding one of the other children of its parent node
         *&#x2F;
        isCollidingABrother:function (threshold) {
            var brother = null;
            for (var n = 0; n &lt; this._parentNode.children.length; n++) {
                brother = this._parentNode.children[n];
                if (brother !== this &amp;&amp; this.isColliding(brother, threshold)) {
                    return true;
                }
            }

            return false;
        },

        &#x2F;*
         * TODO : to be completed
         * Return the list of lines going joigning nodes&#x27; peaks
         * param onlyBrothers a Boolean. Default = true
         * param threshold distance from which the detectection is done
         * return an array of CGSGVector2D (can be empty)
         *&#x2F;
        &#x2F;*getMagneticLines : function(onlyBrothers, threshold) {
         if (!cgsgExist(onlyBrothers)) {
         onlyBrothers = true;
         }

         &#x2F;&#x2F;compute vectors
         var topVector = this.getAbsoluteTop();
         var bottomVector = this.getAbsoluteBottom();
         var leftVector = this.getAbsoluteLeft();
         var rightVector = this.getAbsoluteRight();

         &#x2F;&#x2F;line = a point and a normalized CGSGVector2D (ie : [0, 1] or [1, 0])
         var listOfLines = [];

         var brother = null;
         for (var n = 0; n &lt; this._parentNode.children.length; n++) {
         brother = this._parentNode.children[n];

         &#x2F;&#x2F;vectors v &amp; v&#x27; are colinear if and only if xy’ - yx’ = 0.

         }

         return listOfLines;
         },*&#x2F;

        &#x2F;**
         * Must be overrided by inherited classes
         * @method copy
         * @param {CGSGNode} node
         * @return {CGSGNode} a copy of this node
         *&#x2F;
        copy:function (node) {
            if (node === null || node === undefined) {
                node = new CGSGNode(this.position.x, this.position.y, this.dimension.width, this.dimension.height);
            }
            node.classType = this.classType;
            node.name = this.name;
            node.globalAlpha = this.globalAlpha;
            node.isVisible = this.isVisible;
            node.isProportionalResize = this.isProportionalResize;
            node.pickNodeMethod = this.pickNodeMethod;
            node.needToKeepAbsoluteMatrix  = this.needToKeepAbsoluteMatrix;

            &#x2F;&#x2F;list of the children (empty if this nodes is a leaf)
            &#x2F;&#x2F;this.children = [];

            if (this.regionConstraint !== null) {
                node.regionConstraint = this.regionConstraint.copy();
            }

            &#x2F;&#x2F;can be fulfilled by the developer to put in whatever he needs
            if (this.userdata !== null) {
                node.userdata = this.userdata.copy();
            }

            &#x2F;&#x2F;selection attributes
            &#x2F;&#x2F;if true, this nodes is clickable and so will be checked by the pickNode function
            node.isClickable = this.isClickable;
            &#x2F;&#x2F;if true, this nodes can be selected and so can be transformed (dimension)
            node.isResizable = this.isResizable;
            node.isDraggable = this.isDraggable;
            node.isTraversable = this.isTraversable;

            node.selectionLineColor = this.selectionLineColor;
            node.selectionLineWidth = this.selectionLineWidth;
            node.selectionHandleSize = this.selectionHandleSize;
            node.selectionHandleColor = this.selectionHandleColor;
            node._id = this._id;
            node._ghostColor = cgsgGhostColor;
            node.translateTo(this.position.x, this.position.y);
            node.resizeTo(this.dimension.width, this.dimension.height);
            node.scaleTo(this.scale.x, this.scale.y);
            node.rotateTo(this.rotation.angle);

            node.selectableZone =
                new CGSGRegion(node.position.x, node.position.y, node.dimension.width, node.dimension.height);

            &#x2F;&#x2F;all the events for the node
            node.onMouseOver = this.onMouseOver;
            node.onMouseOut = this.onMouseOut;
            node.onClick = this.onClick;
            node.onDblClick = this.onDblClick;
            node.onDrag = this.onDrag;
            node.onDragEnd = this.onDragEnd;
            node.onResize = this.onResize;
            node.onResizeEnd = this.onResizeEnd;
            node.onSelect = this.onSelect;
            node.onDeselect = this.onDeselect;

            node.computeAbsoluteMatrix(true);

            return node;
        },

        &#x2F;**
         * free memory taken by this object and it&#x27;s children.
         * The &#x27;userData&#x27; property won&#x27;t be freed
         * @method free
         *&#x2F;
        free:function () {
            for (var c = this.children.length - 1; c &gt;= 0; c--) {
                this.children[c].free();
            }

            this.children.clear();

            cgsgFree(this);
        }
    }
);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
