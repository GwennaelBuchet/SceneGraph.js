<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\node\class.node.js - cgSceneGraph</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CGSG.html">CGSG</a></li>
            
                <li><a href="..&#x2F;classes/CGSGAnimationKey.html">CGSGAnimationKey</a></li>
            
                <li><a href="..&#x2F;classes/CGSGAnimationManager.html">CGSGAnimationManager</a></li>
            
                <li><a href="..&#x2F;classes/CGSGBindEntry.html">CGSGBindEntry</a></li>
            
                <li><a href="..&#x2F;classes/CGSGButtonMode.html">CGSGButtonMode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionGhostOnDemandTester.html">CGSGCollisionGhostOnDemandTester</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionManager.html">CGSGCollisionManager</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionMethod.html">CGSGCollisionMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionRegionTester.html">CGSGCollisionRegionTester</a></li>
            
                <li><a href="..&#x2F;classes/CGSGCollisionTesterFactory.html">CGSGCollisionTesterFactory</a></li>
            
                <li><a href="..&#x2F;classes/CGSGColor.html">CGSGColor</a></li>
            
                <li><a href="..&#x2F;classes/CGSGDimension.html">CGSGDimension</a></li>
            
                <li><a href="..&#x2F;classes/CGSGEvent.html">CGSGEvent</a></li>
            
                <li><a href="..&#x2F;classes/CGSGEventManager.html">CGSGEventManager</a></li>
            
                <li><a href="..&#x2F;classes/CGSGHandleBox.html">CGSGHandleBox</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMap.html">CGSGMap</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMask.html">CGSGMask</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMaskCache.html">CGSGMaskCache</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMaskClip.html">CGSGMaskClip</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMath.html">CGSGMath</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNode.html">CGSGNode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeButton.html">CGSGNodeButton</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeCircle.html">CGSGNodeCircle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeColorPicker.html">CGSGNodeColorPicker</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeEllipse.html">CGSGNodeEllipse</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeImage.html">CGSGNodeImage</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSprite.html">CGSGNodeSprite</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSquare.html">CGSGNodeSquare</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeTabMenu.html">CGSGNodeTabMenu</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeText.html">CGSGNodeText</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeWebview.html">CGSGNodeWebview</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticle.html">CGSGParticle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleEmitter.html">CGSGParticleEmitter</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleSystem.html">CGSGParticleSystem</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPickNodeMethod.html">CGSGPickNodeMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPosition.html">CGSGPosition</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRegion.html">CGSGRegion</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRotation.html">CGSGRotation</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScale.html">CGSGScale</a></li>
            
                <li><a href="..&#x2F;classes/CGSGSceneGraph.html">CGSGSceneGraph</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTimeline.html">CGSGTimeline</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTraverser.html">CGSGTraverser</a></li>
            
                <li><a href="..&#x2F;classes/CGSGVector2D.html">CGSGVector2D</a></li>
            
                <li><a href="..&#x2F;classes/CGSGView.html">CGSGView</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWEBVIEWMODE.html">CGSGWEBVIEWMODE</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWrapMode.html">CGSGWrapMode</a></li>
            
                <li><a href="..&#x2F;classes/GLOBAL_CONSTANTS.html">GLOBAL_CONSTANTS</a></li>
            
                <li><a href="..&#x2F;classes/GLOBAL_METHODS.html">GLOBAL_METHODS</a></li>
            
                <li><a href="..&#x2F;classes/GLOBAL_PROPERTIES.html">GLOBAL_PROPERTIES</a></li>
            
                <li><a href="..&#x2F;classes/UTIL_ARRAY.html">UTIL_ARRAY</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Animation.html">Animation</a></li>
            
                <li><a href="..&#x2F;modules/Collision.html">Collision</a></li>
            
                <li><a href="..&#x2F;modules/Math.html">Math</a></li>
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="..&#x2F;modules/Scene.html">Scene</a></li>
            
                <li><a href="..&#x2F;modules/Util.html">Util</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\node\class.node.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2012  Capgemini Technology Services (hereinafter “Capgemini”)
 *
 * License&#x2F;Terms of Use
 *
 * Permission is hereby granted, free of charge and for the term of intellectual property rights on the Software, to any
 * person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to use, copy, modify
 * and propagate free of charge, anywhere in the world, all or part of the Software subject to the following mandatory conditions:
 *
 *   •    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  Any failure to comply with the above shall automatically terminate the license and be construed as a breach of these
 *  Terms of Use causing significant harm to Capgemini.
 *
 *  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  Except as contained in this notice, the name of Capgemini shall not be used in advertising or otherwise to promote
 *  the use or other dealings in this Software without prior written authorization from Capgemini.
 *
 *  These Terms of Use are subject to French law.
 *&#x2F;

&quot;use strict&quot;;

&#x2F;**
 * Base class for a Node in the Scene Graph.
 * Each node encapsulates its position, dimension, scale and rotation, ...
 * @class CGSGNode
 * @extends CGSGObject
 * @module Node
 * @main Node
 * @constructor
 * @param {Number} x Relative position on X
 * @param {Number} y Relative position on Y
 * @type {CGSGNode}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGNode = CGSGObject.extend(
	{
		initialize: function (x, y) {

			&#x2F;**
			 * The name of this nodes. Should be unique, but no control is done.
			 * @property name
			 * @default &quot;&quot;
			 * @type {String}
			 *&#x2F;
			this.name = &quot;&quot;;
			&#x2F;**
			 * Indicate whether this node is selected or not.
			 * Use CGSGView::scenegraph.selectNode(nodeToSelect) to select a node
			 * @property isSelected
			 * @readonly
			 * @default false
			 * @type {Boolean}
			 *&#x2F;
			this.isSelected = false;
			&#x2F;**
			 * The type of this class. Must be redefined by inherited classes
			 * @property classType
			 * @readonly
			 * @type {String}
			 *&#x2F;
			this.classType = &quot;CGSGNODE&quot;;

			&#x2F;**
			 * The 8 handleboxes that will be the resize handles
			 * the resize handles will be in this order:
			 *  0  1  2
			 *  3     4
			 *  5  6  7
			 * @property resizeHandles
			 * @readonly
			 * @type {Array}
			 *&#x2F;
			this.resizeHandles = [];

			&#x2F;**
			 * Level of transparency of the node.
			 * @default 1.0
			 * @property globalAlpha
			 * @type {Number}
			 *&#x2F;
			this.globalAlpha = 1.0;
			&#x2F;**
			 * Indicate if the node is visible (and so selectable) or not
			 * @property isVisible
			 * @default true
			 * @type {Boolean}
			 *&#x2F;
			this.isVisible = true;

			&#x2F;**
			 * If true, the node will be proportionally resized
			 * @property isProportionalResize
			 * @type {Boolean}
			 *&#x2F;
			this.isProportionalResize = false;

            &#x2F;**
             * Set to true if the node can&#x27;t be resized only in height or width
             * @property isProportionalResizeOnly
             * @default false
             * @type {boolean}
             *&#x2F;
            this.isProportionalResizeOnly = false;

			&#x2F;**
			 * Define the method the detection (or &quot;pick&quot;) method will be used for this node.
			 * Possible values CGSGPickNodeMethod.REGION and CGSGPickNodeMethod.GHOST.
			 *
			 * &lt;ul&gt;
			 *     &lt;li&gt;REGION : the detection returns true if the mouse cursor is inside the bounding box of the node&lt;&#x2F;li&gt;
			 *     &lt;li&gt;GHOST : the detection will use the &quot;renderGhost&quot; method of the node to achieve a more accurate detection&lt;&#x2F;li&gt;
			 * &lt;&#x2F;ul&gt;
			 *
			 * @property pickNodeMethod
			 * @default CGSGPickNodeMethod.REGION
			 * @type {CGSGPickNodeMethod}
			 *&#x2F;
			this.pickNodeMethod = CGSGPickNodeMethod.REGION;

			&#x2F;**
			 * List of the children (empty if this nodes is a leaf)
			 * @property children
			 * @readonly
			 * @type {Array}
			 *&#x2F;
			this.children = [];

			&#x2F;**
			 * The constraint region when moving the node
			 * @property regionConstraint
			 * @default null
			 * @type {null}
			 *&#x2F;
			this.regionConstraint = null;

			&#x2F;**
			 * Pivot point to apply a rotation.
			 * The point is a value between [0, 0] and [1, 1].
			 * [0, 0] is the top left corner of the bounding box and [1, 1] the bottom right corner.
			 * @property rotationCenter
			 * @default null
			 * @type {CGSGPosition}
			 *&#x2F;
			this.rotationCenter = null;

			&#x2F;**
			 * can be fulfilled by the developer to put in whatever he needs
			 * @property userdata
			 * @default null
			 * @type {*}
			 *&#x2F;
			this.userdata = null;

			&#x2F;**
			 * selection attributes
			 * If true, this node is clickable and so will be checked by the pickNode function
			 * @property isClickable
			 * @default true
			 * @type {Boolean}
			 *&#x2F;
			this.isClickable = true;
			&#x2F;**
			 * If true, this node can be resized by the user. In that case, the dimension property will be affected, not the scale one.
			 * @property isResizable
			 * @default false
			 * @type {Boolean}
			 *&#x2F;
			this.isResizable = false;
			&#x2F;**
			 * If true, the node can be dragged by the user
			 * @property isDraggable
			 * @default false
			 * @type {Boolean}
			 *&#x2F;
			this.isDraggable = false;

			&#x2F;**
			 * If true, the absolute matrix will be recomputed after each movement (and so in animation).
			 * Set it to false to gain performance if you don&#x27;t need to keep trace of absolute position (no need to collision, picknode, ...)
			 * @property needToKeepAbsoluteMatrix
			 * @default true
			 * @type {Boolean}
			 *&#x2F;
			this.needToKeepAbsoluteMatrix = true;

			&#x2F;**
			 * Color for the line around this node when selected
			 * @property selectionLineColor
			 * @default &quot;#FF6890&quot;
			 * @type {String}
			 *&#x2F;
			this.selectionLineColor = CGSG_DEFAULT_SELECTED_STROKE_COLOR;
			&#x2F;**
			 * Width for the line around this node when selected
			 * @property selectionLineWidth
			 * @default 2
			 * @type {Number}
			 *&#x2F;
			this.selectionLineWidth = CGSG_DEFAULT_SELECTED_STROKE_SIZE;
			&#x2F;**
			 * Color for the handle boxes around this node when selected
			 * @property selectionHandleSize
			 * @default 6
			 * @type {Number}
			 *&#x2F;
			this.selectionHandleSize = CGSG_DEFAULT_SELECTED_RESIZEHANDLE_SIZE;
			&#x2F;**
			 * Color for the handle boxes around this node when selected
			 * @property selectionHandleColor
			 * @default &quot;#9068FF&quot;&quot;
			 * @type {String}
			 *&#x2F;
			this.selectionHandleColor = CGSG_DEFAULT_SELECTED_RESIZEHANDLE_COLOR;

			&#x2F;**
			 * Updated by the scene itself. Don&#x27;t update it manually.
			 * True if the mice is over the node, false otherwise
			 * @property isMouseOver
			 * @readonly
			 * @type {Boolean}
			 *&#x2F;
			this.isMouseOver = false;
			&#x2F;**
			 * Updated by the scene itself. Don&#x27;t update it manually.
			 * True if the node is being moved manually, false otherwise
			 * @property isMoving
			 * @readonly
			 * @type {Boolean}
			 *&#x2F;
			this.isMoving = false;
			&#x2F;**
			 * Updated by the scene itself. Don&#x27;t update it manually.
			 * True if the node is being resized manually, false otherwise
			 * @property isResizing
			 * @readonly
			 * @type {Boolean}
			 *&#x2F;
			this.isResizing = false;

			&#x2F;**
			 * ID for the node. Should be filled by the developer. The framework will never use it.
			 * @property _id
			 * @type {Number}
			 * @private
			 *&#x2F;
			this._id = 0;
			&#x2F;**
			 * parent of this node
			 * @property _parentNode
			 * @type {CGSGNode}
			 * @private
			 *&#x2F;
			this._parentNode = null;

            this._isPrecomputed = false;
            &#x2F;&#x2F;fake canvas to pre-render static display
            this._tmpCanvas = null;
            this._tmpContext = null;

            &#x2F;**
             * @property shadowOffsetX
             * @default 0
             * @type {number}
             *&#x2F;
            this.shadowOffsetX = 0;
            &#x2F;**
             * @property shadowOffsetY
             * @default 0
             * @type {number}
             *&#x2F;
            this.shadowOffsetY = 0;
            &#x2F;**
             * @property shadowBlur
             * @default 0
             * @type {number}
             *&#x2F;
            this.shadowBlur = 0;
            &#x2F;**
             * @property shadowColor
             * @default &quot;#333333&quot;
             * @type {string}
             *&#x2F;
            this.shadowColor = &quot;#333333&quot;;

			&#x2F;**
			 * Relative position of this nodes on the canvas container, relatively to the position of its parent node.
			 * Never use it to move the node, use translateBy&#x2F;translateWith&#x2F;translateTo instead
			 * @readonly
			 * @property position
			 * @default CGSGPosition(0, 0)
			 * @type {CGSGPosition}
			 *&#x2F;
			this.position = new CGSGPosition(0, 0);
			&#x2F;**
			 * Absolute position of this nodes on the canvas container. Generated value. Don&#x27;t modify it manually
			 * Never use it to move the node, use translateBy&#x2F;translateWith&#x2F;translateTo instead
			 * @readonly
			 * @property _absolutePosition
			 * @private
			 * @type {CGSGPosition}
			 *&#x2F;
			this._absolutePosition = new CGSGPosition(0, 0);
			&#x2F;**
			 * Dimension of this nodes on the canvas container
			 * Never use it to resize the node, use resizeBy&#x2F;resizeWith&#x2F;resizeTo instead
			 * @readonly
			 * @property dimension
			 * @default CGSGDimension(0, 0)
			 * @type {CGSGDimension}
			 *&#x2F;
			this.dimension = new CGSGDimension(0, 0);
			&#x2F;**
			 * Relative scale of this nodes on the canvas container, relatively to the scale of its parent node.
			 * Never use it to scale or resize the node, use scaleBy&#x2F;scaleWith&#x2F;scaleTo instead
			 * @readonly
			 * @property scale
			 * @default CGSGScale(1, 1)
			 * @type {CGSGScale}
			 *&#x2F;
			this.scale = new CGSGScale(1, 1);
			&#x2F;**
			 * Absolute scale of this nodes on the canvas container. Generated value. Don&#x27;t modify it manually
			 * Never use it to scale the node, use scaleBy&#x2F;scaleWith&#x2F;scaleTo instead
			 * @readonly
			 * @property _absoluteScale
			 * @private
			 * @type {CGSGScale}
			 *&#x2F;
			this._absoluteScale = new CGSGScale(1, 1);
			&#x2F;**
			 * Relative rotation of this nodes on the canvas container, relatively to the rotation of its parent node.
			 * Never use it to rotate or resize the node, use rotateBy&#x2F;rotateWith&#x2F;rotateTo instead
			 * @readonly
			 * @property rotation
			 * @default CGSGRotation(0)
			 * @type {CGSGRotation}
			 *&#x2F;
			this.rotation = new CGSGRotation(0);
			&#x2F;**
			 * Absolute rotation of this nodes on the canvas container. Generated value. Don&#x27;t modify it manually
			 * Never use it to rotate or resize the node, use rotateBy&#x2F;rotateWith&#x2F;rotateTo instead
			 * @readonly
			 * @private
			 * @property _absoluteRotation
			 * @type {CGSGRotation}
			 *&#x2F;
			this._absoluteRotation = new CGSGRotation(0);

			&#x2F;**
			 * @property _isDrag
			 * @type {Boolean}
			 * @private
			 *&#x2F;
			this._isDrag = false;

			&#x2F;&#x2F;this.selectableZone =
			&#x2F;&#x2F;new CGSGRegion(this.position.x, this.position.y, this.dimension.width, this.dimension.height);

			&#x2F;**
			 * true if this node is traversable (recursively) (ie : by the picknode, a traverser, ...)
			 * @property isTraversable
			 * @type {Boolean}
			 *&#x2F;
			this.isTraversable = true;

            &#x2F;**
             * Indicate if this node is managed by the collision manager
             * @property isCollisionManaged
             * @type {Boolean}
             *&#x2F;
            this.isCollisionManaged = false;

			&#x2F;&#x2F;initialize the position and dimension
			this.translateTo(x, y, true);
			this.resizeTo(0, 0);

            &#x2F;**
             * Set to true if dimension of the node is not the original one anymore
             * @property _isDimensionChanged
             * @default false
             * @private
             *&#x2F;
            this._isDimensionChanged = false;

			&#x2F;&#x2F; initialize the selection handleBoxes
			for (var i = 0; i &lt; 8; i++) {
				var handleBox = new CGSGHandleBox(this, this.selectionHandleSize, this.selectionHandleColor,
												  this.selectionLineColor, this.selectionLineWidth, 0, 0);
				this.resizeHandles.push(handleBox);
			}

			&#x2F;**
			 * Callback on mouse over the node
			 * @property onMouseOver
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onMouseOver = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onMouseOver = null;
			&#x2F;**
			 * Callback on mouse enter on the node
			 * @property onMouseEnter
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onMouseEnter = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onMouseEnter = null;
			&#x2F;**
			 * Callback on mouse out
			 * @property onMouseOut
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onMouseOut = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onMouseOut = null;
			&#x2F;**
			 * Callback on mouse up
			 * @property onMouseUp
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onMouseUp = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onMouseUp = null;
			&#x2F;**
			 * Callback on mouse or touch click
			 * @property onClick
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onClick = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onClick = null;
			&#x2F;**
			 * Callback on mouse or touch double click
			 * @property onDblClick
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onDblClick = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onDblClick = null;
			&#x2F;**
			 * Callback on drag this node
			 * @property onDrag
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onDrag = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onDrag = null;
			&#x2F;**
			 * Callback on end of drag this node
			 * @property onDragEnd
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onDragEnd = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onDragEnd = null;
			&#x2F;**
			 * Callback on resize this node
			 * @property onResize
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onResize = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onResize = null;
			&#x2F;**
			 * Callback on end resize this node
			 * @property onResizeEnd
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onResizeEnd = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onResizeEnd = null;
			&#x2F;**
			 * Callback on select this node
			 * @property onSelect
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onSelect = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onSelect = null;

			&#x2F;**
			 * Callback on deselect this node
			 * @property onDeselect
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onDeselect = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onDeselect = null;

			&#x2F;**
			 * Callback on when a child is removed
			 * @property onChildRemove
			 * @default null
			 * @type {function}
			 *
			 * @example
			 *  this.onDeselect = function (event) {
			 *      event.data.node; &#x2F;&#x2F;CGSGNode
			 *      event.data.position; &#x2F;&#x2F;Array of CGSGPosition
			 *      event.data.nativeEvent; &#x2F;&#x2F;Event
			 *  }
			 *&#x2F;
			this.onChildRemove = null;

			this.computeAbsoluteMatrix(true);
		},

        &#x2F;**
         * @method moveLocalZIndex
         * @param {Number} step
         *&#x2F;
        moveLocalZIndex: function (step) {
            var index = this.getLocalZIndex();

            if (!isNaN(index)) {
                this.setLocalZIndex(this.getLocalZIndex() + step);
            }
        },

        setLocalZIndex: function (index) {
            if (cgsgExist(this._parentNode)) {
                index = Math.max(0, Math.min(CGSGMath.fixedPoint(index), this._parentNode.children.length - 1));

                var n = this.getLocalZIndex();
                var p = this._parentNode;

                if (index != n) {
                    p.detachChild(this);
                    p.addChildAt(this, index);
                }
            }
        },

        setLocalZIndexToLast: function () {
            this.setLocalZIndex(this._parentNode.children.length - 1);
        },

        getLocalZIndex: function () {
            if (!cgsgExist(this._parentNode))
                return NaN;

            return this._parentNode.children.indexOf(this);
        },

		&#x2F;**
		 * return the relative region of this node
		 * @public
		 * @method getRegion
		 * @return {CGSGRegion}
		 *&#x2F;
		getRegion: function () {
			return new CGSGRegion(this.position.x, this.position.y, this.getWidth(), this.getHeight());
		},

		&#x2F;**
		 * return the absolute region of this node
		 * @public
		 * @method getAbsoluteRegion
		 * @return {CGSGRegion}
		 *&#x2F;
		getAbsoluteRegion: function () {
			return new CGSGRegion(this.getAbsoluteLeft(), this.getAbsoluteTop(), this.getAbsoluteWidth(),
								  this.getAbsoluteHeight());
		},

		&#x2F;&#x2F;&#x2F;&#x2F; RENDERING MANIPULATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

		&#x2F;**
		 * Wipes the canvas context
		 * @method _clearContext
		 * @param context
		 * @param canvasWidth
		 * @param canvasHeight
		 * @private
		 *&#x2F;
		_clearContext: function (context, canvasWidth, canvasHeight) {
			context.clearRect(0, 0, canvasWidth, canvasHeight);
		},

        &#x2F;**
         * Use this method to make the node precomputed or not.
         * If it&#x27;s precomputed, it won&#x27;t be redraw every frame, but only when the &quot;invalidate&quot; method is called.
         * @method setPrecomputed
         * @param {Boolean} isPrecomputed
         *&#x2F;
        setPrecomputed: function (isPrecomputed) {
            this._isPrecomputed = isPrecomputed;
            this.invalidate();
        },

        &#x2F;**
         * Force the redraw of the node if it&#x27;s precomputed
         * @method invalidate
         *&#x2F;
        invalidate: function () {
            if (this._isPrecomputed) {
                this._preCompute();
            }
        },

        &#x2F;**
         * @method _applyShadow
         * @param ctx
         * @private
         *&#x2F;
        _applyShadow: function (ctx) {
            if (this.shadowOffsetX !== 0 || this.shadowOffsetY !== 0) {
                ctx.shadowOffsetX = this.shadowOffsetX;
                ctx.shadowOffsetY = this.shadowOffsetY;
                ctx.shadowBlur = this.shadowBlur;
                ctx.shadowColor = this.shadowColor;
            }
        },

        &#x2F;**
         * @method _preCompute
         * @private
         *&#x2F;
        _preCompute: function () {
            if (!cgsgExist(this._tmpCanvas)) {
                this._tmpCanvas = document.createElement(&#x27;canvas&#x27;);
                this._tmpContext = this._tmpCanvas.getContext(&#x27;2d&#x27;);
            }
            this._tmpCanvas.width = CGSG.canvas.width;
            this._tmpCanvas.height = CGSG.canvas.height;
            cgsgClearContext(this._tmpContext);

            this._applyShadow(this._tmpContext);
            this.render(this._tmpContext);
        },

        &#x2F;**
         * internal method of the framework that encapsulate all the work aroud the rendering method
         * @method doRender
         * @param {CanvasRenderingContext2D} context
         *&#x2F;
        doRender: function (context) {
            &#x2F;*var start = new CGSGEvent(this, {context : context});

            if (node.onBeginRender) {
                CGSG.eventManager.dispatch(node, cgsgEventTypes.ON_BEGIN_RENDER, start);
            }

            &#x2F;&#x2F; Render if context exists
            if (cgsgExist(start.data.context)) {
                node.render(start.data.context, CGSG.currentFrame);
            }

            var end = new CGSGEvent(this, {context : start.data.context});

            if (node.onFinishRender) {
                CGSG.eventManager.dispatch(node, cgsgEventTypes.ON_FINISH_RENDER, end);
            }

            return end.data.context;*&#x2F;

            var ctx = context;

            var startEvt = new CGSGEvent(this, {context : context});

            if (cgsgExist(this.onBeforeRender)) {
               CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_BEFORE_RENDER, startEvt);
                ctx = startEvt.data.context;
                &#x2F;&#x2F;this.onBeforeRender({context: context});
            }

            &#x2F;&#x2F;save current state
            this.beforeRender(ctx);

            if (this.globalAlpha &gt; 0) {
                ctx.globalAlpha = this.globalAlpha;

                if (this._isPrecomputed) {
                    &#x2F;&#x2F;render the pre-rendered canvas
                    ctx.drawImage(this._tmpCanvas, 0, 0);
                }
                else {
                    this._applyShadow(ctx);
                    this.render(ctx);
                }
            }


            var endEvt = new CGSGEvent(this, {context : ctx});

            &#x2F;&#x2F;restore state
            this.afterRender(endEvt.data.context);

            if (cgsgExist(this.onAfterRender)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_AFTER_RENDER, endEvt);
                ctx = endEvt.data.context;
                &#x2F;&#x2F;this.onAfterRender({context: context});
            }

        },

        &#x2F;**
		 * Empty rendering function. Must be overrided by the inherited classes
		 * @method render
		 * @param {CanvasRenderingContext2D} context the context into render the node
		 * *&#x2F;
		render: function (context) {
		},

        &#x2F;**
         * internal method of the framework that encapsulate all the work around the ghost rendering method
         * @method doRenderGhost
         * @param {CanvasRenderingContext2D} ghostContext
         *&#x2F;
        doRenderGhost: function (ghostContext) {
            &#x2F;&#x2F;save current state
            this.beforeRenderGhost(ghostContext);

            if (this.globalAlpha &gt; 0) {
                if (this._isPrecomputed) {
                    &#x2F;&#x2F;render the pre-rendered canvas
                    ghostContext.drawImage(this._tmpCanvas, 0, 0);
                }
                else {
                    this.renderGhost(ghostContext);
                }
            }

            &#x2F;&#x2F;restore state
            this.afterRenderGhost(ghostContext);
        },

        &#x2F;**
         * Empty ghost rendering function.
         * Render here your custom nodes with a single color (CGSG.ghostColor).
         * This will be used by the SceneGraph to know if the mouse cursor is over this nodes.
         *
         * @method renderGhost
         * @param ghostContext The context for the ghost rendering
         *&#x2F;
        renderGhost: function (ghostContext) {
            this.render(ghostContext);
        },

		&#x2F;**
		 * Render the selection box and handle boxes around the bounding box of this node when selected
		 * @protected
		 * @method renderBoundingBox
		 * @param {CanvasRenderingContext2D} context the context into render the node
		 * *&#x2F;
		renderBoundingBox: function (context) {
            &#x2F;&#x2F;this.computeAbsoluteMatrix(true);

            var w = this.getWidth(), h = this.getHeight();

            context.strokeStyle = this.selectionLineColor;

            context.lineWidth = this.selectionLineWidth &#x2F; this._absoluteScale.y;
            context.beginPath();
            &#x2F;&#x2F;top line
            context.moveTo(0, 0);
            context.lineTo(w, 0);
            &#x2F;&#x2F;bottom line
            context.moveTo(0, h);
            context.lineTo(w, h);
            context.stroke();
            context.closePath();

            context.lineWidth = this.selectionLineWidth &#x2F; this._absoluteScale.x;
            context.beginPath();
            &#x2F;&#x2F;left line
            context.moveTo(0, 0);
            context.lineTo(0, h);
            &#x2F;&#x2F;right line
            context.moveTo(w, 0);
            context.lineTo(w, h);
            context.stroke();
            context.closePath();

            &#x2F;&#x2F;draw the resize handles
            if (this.isResizable) {
                &#x2F;&#x2F; draw the handle boxes
                var halfX = this.selectionHandleSize &#x2F; (2 * this._absoluteScale.x);
                var halfY = this.selectionHandleSize &#x2F; (2 * this._absoluteScale.y);

                &#x2F;&#x2F; 0  1  2
                &#x2F;&#x2F; 3     4
                &#x2F;&#x2F; 5  6  7

                &#x2F;&#x2F; top left, middle, right
                this.resizeHandles[0].translateTo(-halfX, -halfY);
                this.resizeHandles[1].translateTo(w &#x2F; 2 - halfX, -halfY);
                this.resizeHandles[2].translateTo(w - halfX, -halfY);

                &#x2F;&#x2F; middle left
                this.resizeHandles[3].translateTo(-halfX, h &#x2F; 2 - halfY);

                &#x2F;&#x2F; middle right
                this.resizeHandles[4].translateTo(w - halfX, h &#x2F; 2 - halfY);

                &#x2F;&#x2F; bottom left, middle, right
                this.resizeHandles[6].translateTo(w &#x2F; 2 - halfX, h - halfY);
                this.resizeHandles[5].translateTo(-halfX, h - halfY);
                this.resizeHandles[7].translateTo(w - halfX, h - halfY);

                if (this.isProportionalResizeOnly) {
                    this.resizeHandles[1].isVisible = false;
                    this.resizeHandles[3].isVisible = false;
                    this.resizeHandles[4].isVisible = false;
                    this.resizeHandles[6].isVisible = false;
                }

                var i;
                for (i = 0; i &lt; 8; i++) {
                    this.resizeHandles[i].size = this.selectionHandleSize;
                    this.resizeHandles[i].fillColor = this.selectionHandleColor;
                    this.resizeHandles[i].strokeColor = this.selectionLineColor;
                    this.resizeHandles[i].lineWidth = this.selectionLineWidth;
                    this.resizeHandles[i].render(context);
                }
            }
		},

		&#x2F;**
		 * Must be called before to start the rendering of the nodes
		 * @protected
		 * @method beforeRender
		 * @param {CanvasRenderingContext2D} context the context into render the nodes
		 * *&#x2F;
		beforeRender: function (context) {
			&#x2F;&#x2F;first save the current context state
			context.save();

			&#x2F;&#x2F;move the context to the nodes&#x27;s relative position
			context.translate(this.position.x, this.position.y);
            context.scale(this.scale.x, this.scale.y);

			&#x2F;&#x2F; translate context to center of canvas
			if (cgsgExist(this.rotationCenter)) {
				context.translate(this.dimension.width * this.rotationCenter.x,
								  this.dimension.height * this.rotationCenter.y);
				context.rotate(this.rotation.angle);
				context.translate(-this.dimension.width * this.rotationCenter.x,
								  -this.dimension.height * this.rotationCenter.y);
			}
			else {
				context.rotate(this.rotation.angle);
			}

            if (this.onBeforeRenderEnd) {
               CGSG.eventManager.dispatch(this, cgsgEventTypes.BEFORE_RENDER_END, new CGSGEvent(this, {context : context}));
            }
		},

		&#x2F;**
		 * Must be called after a render
		 * @protected
		 * @method afterRender
		 * @param {CanvasRenderingContext2D} context the context into render the nodes
		 * *&#x2F;
		afterRender: function (context) {
            if (this.onAfterRenderStart) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.AFTER_RENDER_START, new CGSGEvent(this, {context : context}));
            }

            &#x2F;&#x2F;var ctx = context;

			&#x2F;&#x2F;render all children
			if (!this.isALeaf()) {
				&#x2F;&#x2F;draw children
				for (var i = 0, len = this.children.length; i &lt; len; ++i) {
					var childNode = this.children[i];
					if (childNode.isVisible) {
                        &#x2F;&#x2F;&#x2F;&#x2F; ctx = cgsgRender(ctx, childNode);
                        childNode.doRender(context);
					}
				}
			}

			&#x2F;&#x2F;restore the context state
			context.restore();
		},

		&#x2F;**
		 * Must be called before begin to render the nodes in GHOST mode
		 * @protected
		 * @method beforeRenderGhost
		 * @param {CanvasRenderingContext2D} context the context into render the nodes
		 *&#x2F;
		beforeRenderGhost: function (context) {
			&#x2F;&#x2F;first save the current context state
			context.save();
			&#x2F;&#x2F;move the context to the nodes&#x27;s relative position
			context.translate(this._absolutePosition.x, this._absolutePosition.y);
			context.rotate(this._absoluteRotation.angle);
			context.scale(this._absoluteScale.x, this._absoluteScale.y);
		},

		&#x2F;**
		 * Must be called before begin to render
		 * @protected
		 * @method afterRenderGhost
		 * @param {CanvasRenderingContext2D} context the context into render the nodes
		 * *&#x2F;
		afterRenderGhost: function (context) {
			&#x2F;&#x2F;restore the context state
			context.restore();
		},

		&#x2F;**
		 * Mark this nodes as selected
		 * @method setSelected
		 * @param {Boolean} isSelected
		 * *&#x2F;
		setSelected: function (isSelected) {
			this.isSelected = isSelected;
			this._isDrag = true;

			if (isSelected &amp;&amp; this.onSelect !== null) {
				&#x2F;&#x2F;this.onSelect({node: this});
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SELECT, new CGSGEvent(this, {node: this}));
			}
			else if (this.onDeselect !== null) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_DESELECT, new CGSGEvent(this, {node: this}));
				&#x2F;&#x2F;this.onDeselect({node: this});
			}
		},

        &#x2F;**
         * Returns a region which represents the total surface covered by this node and its children too.
         * @protected
         * @method getCompleteRegion
         * @return {CGSGRegion}
         *&#x2F;
        getCompleteRegion : function() {
            return new CGSGRegion(this.getMinAbsoluteLeft(), this.getMinAbsoluteTop(), this.getMaxAbsoluteRight(), this.getMaxAbsoluteBottom());
        },

        &#x2F;**
         * Returns a position which represents the lowest position covered between this node and its children too.
         * @protected
         * @method getCompletePosition
         * @return {CGSGPosition}
         *&#x2F;
        getCompletePosition : function() {
            return new CGSGPosition(this.getMinAbsoluteLeft(), this.getMinAbsoluteTop());
        },

        &#x2F;**
         * Returns a position which represents the highest dimension covered between this node and its children too.
         * @protected
         * @method getCompleteDimension
         * @return {CGSGDimension}
         *&#x2F;
        getCompleteDimension : function() {
            return new CGSGDimension(this.getMaxAbsoluteRight(), this.getMaxAbsoluteBottom());
        },

		&#x2F;**
		 * return this if this nodes is under the mice cursor
		 * Can be overrided by inherited klass to optimize this perform.
		 * This default function used the ghost rendering method
		 * @protected
		 * @method detectSelection
		 * @param {CGSGPosition} mousePosition A CGSGPosition object
		 * @param {CanvasRenderingContext2D} ghostContext
		 * @param {CGSGScale} absoluteScale
		 *&#x2F;
		detectSelection: function (mousePosition, ghostContext, absoluteScale) {
			if (this.pickNodeMethod == CGSGPickNodeMethod.REGION) {
				if (mousePosition.x &gt;= this._absolutePosition.x
						&amp;&amp; mousePosition.x &lt; this._absolutePosition.x + this.getWidth() * absoluteScale.x
						&amp;&amp; mousePosition.y &gt;= this._absolutePosition.y
					    &amp;&amp; mousePosition.y &lt; this._absolutePosition.y + this.getHeight() * absoluteScale.y
					) {
					return this;
				}
			}
			else &#x2F;*if (this.pickNodeMethod == CGSGPickNodeMethod.GHOST)*&#x2F; {
				&#x2F;&#x2F; draw shape onto ghost context
				this.doRenderGhost(ghostContext);

				&#x2F;&#x2F; get image data at the mouse x,y pixel
				var imageData = ghostContext.getImageData(mousePosition.x, mousePosition.y, 1, 1);

				cgsgClearContext(ghostContext);

				&#x2F;&#x2F; if the mouse pixel exists, select this nodes
				if (imageData.data[0] != 0 || imageData.data[1] != 0 || imageData.data[2] != 0) {
					return this;
				}
			}

			return null;
		},

		&#x2F;**
		 * return this if this nodes is under the region
		 * Can be overrided by inherited klass to optimize this perform.
		 * This default function used the ghost rendering method
		 * @protected
		 * @method detectSelectionInRegion
		 * @param {CGSGRegion} region The region to check
		 * @param {CanvasRenderingContext2D} ghostContext
		 * @param {CGSGScale} absoluteScale
		 *&#x2F;
		detectSelectionInRegion: function (region, ghostContext, absoluteScale) {

			if (this.pickNodeMethod == CGSGPickNodeMethod.REGION) {

				var us = this.getAbsoluteRegion();
				&#x2F;&#x2F;select this node only if it is totally inside the region
				if (cgsgRegionIsInRegion(us, region, 0)) {
					return this;
				}

			}
			else &#x2F;*if (this.pickNodeMethod == CGSGPickNodeMethod.GHOST)*&#x2F; {
				&#x2F;&#x2F; draw shape onto ghost context
				this.renderGhost(ghostContext);

				&#x2F;&#x2F; get image data at the mouse x,y pixel
				var imageData = ghostContext.getImageData(region.position.x, region.position.y, region.dimension.width,
														  region.dimension.height);

				cgsgClearContext(ghostContext);

				&#x2F;&#x2F; if the a pixel exists in the region then, select this node
                for (var i = 0, len = imageData.data.length; i &lt; len; i += 4) {
                    if (imageData.data[i] != 0 || imageData.data[i + 1] != 0 || imageData.data[i + 2] != 0) {
						return this;
					}
				}
			}

			return null;
		},

		&#x2F;**
		 * Check if this nodes is under the cursor position.
		 * @public
		 * @method pickNode
		 * @param {CGSGPosition} mousePosition position of the mouse on the canvas
		 * @param {CGSGScale} absoluteScale a CGSGScale absolute relativeScale of all parents
		 * @param {CanvasRenderingContext2D} ghostContext a copy of the canvas context
		 * @param {Boolean} recursively if false, don&#x27;t traverse the children of this nodes
		 * @param {Function} condition Condition to be picked
		 * ie: &quot;color==&#x27;yellow&#x27;&quot; or &quot;classType==&#x27;CGSGNodeImage&#x27; &amp;&amp; this.globalAlpha&gt;0.5&quot;
		 *&#x2F;
		pickNode: function (mousePosition, absoluteScale, ghostContext, recursively, condition) {
			var selectedNode = null;
			var childAbsoluteScale = null;
			if (cgsgExist(absoluteScale)) {
                childAbsoluteScale = absoluteScale.multiply(this.scale);
			}
			else {
				childAbsoluteScale = this.getAbsoluteScale(false);
			}

			if (this.isTraversable &amp;&amp; (this.isClickable || this.isResizable || this.isDraggable)) {
				if (!cgsgExist(condition) || condition(this) === true) {
					this.computeAbsoluteMatrix(false);

                    &#x2F;&#x2F; First of all, try to to see if resize handler has been picked
                    if (this.isSelected &amp;&amp; this.isResizable) {
                        for (var h = 0; h &lt; 8; h++) {
                            var selectionHandle = this.resizeHandles[h];

                            if (selectionHandle.checkIfSelected(mousePosition, CGSG.resizeHandleThreshold)) {
                                return this;
                            }
                        }
                    }

					selectedNode =
					this.detectSelection(mousePosition, ghostContext, childAbsoluteScale);
				}
			}

			&#x2F;&#x2F;traverse the children if asked
			if (this.isTraversable &amp;&amp; recursively &amp;&amp; !this.isALeaf()) {
				for (var i = this.children.length - 1; i &gt;= 0; --i) {
					var childNode = this.children[i];
					var selectedChild = childNode.pickNode(mousePosition,
														   childAbsoluteScale, ghostContext,
														   recursively, condition);
					if (cgsgExist(selectedChild)) {
						selectedNode = selectedChild;
						break;
					}
				}

				childAbsoluteScale = null;
			}

			return selectedNode;
		},

		&#x2F;**
		 * Return all nodes (Array) in the given region
		 * @public
		 * @method pickNodes
		 * @param {CGSGRegion} region of the canvas to check
		 * @param {CGSGScale} absoluteScale a CGSGScale absolute relativeScale of all parents
		 * @param {CanvasRenderingContext2D} ghostContext a copy of the canvas context
		 * @param {Boolean} recursively if false, don&#x27;t traverse the children of this nodes
		 * @param {Function} condition Condition to be picked
		 * ie: &quot;color==&#x27;yellow&#x27;&quot; or &quot;classType==&#x27;CGSGNodeImage&#x27; &amp;&amp; this.globalAlpha&gt;0.5&quot;
		 *&#x2F;
		pickNodes: function (region, absoluteScale, ghostContext, recursively, condition) {
			var selectedNodes = [];

            if (region.dimension.width == 0 &amp;&amp; region.dimension.height == 0)
                return selectedNodes;

			var childAbsoluteScale = null;
			if (cgsgExist(absoluteScale)) {
                childAbsoluteScale = absoluteScale.multiply(this.scale);
			}
			else {
				childAbsoluteScale = this.getAbsoluteScale(false);
			}

			if (this.isTraversable &amp;&amp; (&#x2F;*this.isClickable ||*&#x2F; this.isResizable || this.isDraggable)) {
				if (!cgsgExist(condition) || condition(this) === true) {
					this.computeAbsoluteMatrix(false);
					var selected = this.detectSelectionInRegion(region, ghostContext, childAbsoluteScale);
					if (cgsgExist(selected)) {
						selectedNodes.push(selected);
					}
				}
			}

			&#x2F;&#x2F;traverse the children if asked
			if (this.isTraversable &amp;&amp; recursively &amp;&amp; !this.isALeaf()) {
				for (var i = this.children.length - 1; i &gt;= 0; --i) {
					var childNode = this.children[i];
					var selectedChildren = childNode.pickNodes(region,
															   childAbsoluteScale, ghostContext,
															   recursively, condition);
					if (selectedChildren !== null &amp;&amp; selectedChildren !== undefined) {
						selectedNodes = selectedNodes.concat(selectedChildren);
					}
				}

				childAbsoluteScale = null;
			}

			return selectedNodes;
		},

		&#x2F;**
		 * Return true if this nodes has no child
		 * @method isALeaf
		 * *&#x2F;
		isALeaf: function () {
			return this.children.length &lt;= 0;
		},

		&#x2F;&#x2F;&#x2F;&#x2F; TRANSFORMATION MANIPULATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

		&#x2F;**
		 * Replace current relative position by this new one
		 * @method translateTo
		 * @param {Number} newRelativeX
		 * @param {Number} newRelativeY
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 *&#x2F;
		translateTo: function (newRelativeX, newRelativeY, computeAbsoluteValue) {
			this.position.translateTo(newRelativeX, newRelativeY);
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absolutePosition = this.getAbsolutePosition(true);
			}

            if (cgsgExist(this.onTranslate)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_TRANSLATE, new CGSGEvent(this, null));
            }
		},

		&#x2F;**
		 * Add new coordinate to the current relative one
		 * @method translateWith
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		translateWith: function (x, y, computeAbsoluteValue) {
			this.position.translateWith(x, y);
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absolutePosition = this.getAbsolutePosition(true);
			}

            if (cgsgExist(this.onTranslate)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_TRANSLATE, new CGSGEvent(this, null));
            }
		},

		&#x2F;**
		 * Add new coordinate to the current relative one
		 * @method translateBy
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		translateBy: function (x, y, computeAbsoluteValue) {
			this.position.translateBy(x, y);
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absolutePosition = this.getAbsolutePosition();
			}

            if (cgsgExist(this.onTranslate)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_TRANSLATE, new CGSGEvent(this, null));
            }
		},

		&#x2F;**
		 * Replace current dimension by these new ones
		 * @method resizeTo
		 * @param {Number} newWidth
		 * @param {Number} newHeight
		 * *&#x2F;
		resizeTo: function (newWidth, newHeight) {
			this.dimension.resizeTo(newWidth, newHeight);
            this._isDimensionChanged = true;
            this.invalidate();
            if (cgsgExist(this.onResize)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_RESIZE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Multiply current dimension by these new ones
		 * @method resizeTBy
		 * @param {Number} widthFactor
		 * @param {Number} heightFactor
		 * *&#x2F;
		resizeBy: function (widthFactor, heightFactor) {
			this.dimension.resizeBy(widthFactor, heightFactor);
            this._isDimensionChanged = true;
            this.invalidate();
            if (cgsgExist(this.onResize)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_RESIZE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Increase&#x2F;decrease current dimension with adding values
		 * @method resizeWith
		 * @param {Number} width
		 * @param {Number} height
		 * *&#x2F;
		resizeWith: function (width, height) {
			this.dimension.resizeWith(width, height);
            this._isDimensionChanged = true;
            this.invalidate();
            if (cgsgExist(this.onResize)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_RESIZE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Replace current relative relativeScale by this new one
		 * @method scaleTo
		 * @param {Number} scaleX
		 * @param {Number} scaleY
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		scaleTo: function (scaleX, scaleY, computeAbsoluteValue) {
			this.scale.x = scaleX;
			this.scale.y = scaleY;
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absoluteScale = this.getAbsoluteScale(true);
			}

            if (cgsgExist(this.onScale)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCALE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Multiply this relativeScale factor by the current relative relativeScale
		 * @method scaleBy
		 * @param {Number} scaleFactorX
		 * @param {Number} scaleFactorY
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		scaleBy: function (scaleFactorX, scaleFactorY, computeAbsoluteValue) {
			this.scale.x *= scaleFactorX;
			this.scale.y *= scaleFactorY;
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absoluteScale = this.getAbsoluteScale(true);
			}

            if (cgsgExist(this.onScale)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCALE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Add to the current relative Scale
		 * @method scaleWith
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		scaleWith: function (x, y, computeAbsoluteValue) {
			this.scale.x += x;
			this.scale.y += y;
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absoluteScale = this.getAbsoluteScale(true);
			}

            if (cgsgExist(this.onScale)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_SCALE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Replace current relative relativeRotation by this new oneScale
		 * @method rotateTo
		 * @param {Number} newAngle
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 *
		 * *&#x2F;
		rotateTo: function (newAngle, computeAbsoluteValue) {
			this.rotation.rotateTo(newAngle);
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absoluteRotation = this.getAbsoluteRotation(true);
			}

            if (cgsgExist(this.onRotate)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_ROTATE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Multiply this relativeScale factor by the current relative relativeScale
		 * @method rotateBy
		 * @param {Number} rotateFactor
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		rotateBy: function (rotateFactor, computeAbsoluteValue) {
			this.rotation.rotateBy(rotateFactor);
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absoluteRotation = this.getAbsoluteRotation(true);
			}

            if (cgsgExist(this.onRotate)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_ROTATE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;**
		 * Add this angle to the current relative relativeRotation
		 * @method rotateWith
		 * @param {Number} angle
		 * @param {Boolean} computeAbsoluteValue (default: true)
		 * *&#x2F;
		rotateWith: function (angle, computeAbsoluteValue) {
			this.rotation.rotateWith(angle);
			if (this.needToKeepAbsoluteMatrix &amp;&amp; computeAbsoluteValue !== false) {
				this._absoluteRotation = this.getAbsoluteRotation(true);
			}

            if (cgsgExist(this.onRotate)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_ROTATE, new CGSGEvent(this, {node:this}));
            }
		},

		&#x2F;&#x2F;&#x2F;&#x2F; CHILDREN MANIPULATION &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

		&#x2F;**
		 * Add a new nodes into this one, at the end of the list
		 * @method addChild
		 * @param {CGSGNode} newNode the nodes to add as a child
		 * *&#x2F;
		addChild: function (newNode) {
			newNode._parentNode = this;
			this.children[this.children.length] = newNode;
		},

		&#x2F;**
		 * Add a new nodes at a particular index in the list of children.
		 * If the index is too large, the nodes will be inserted at the end of the list
		 * @method addChildAt
		 * @param {CGSGNode} newNode the nodes to insert as a child
		 * @param {Number} index the position of the new child in the list
		 * *&#x2F;
		addChildAt: function (newNode, index) {
			if (index &gt; this.children.length) {
				index = this.children.length;
			}

			for (var i = this.children.length; i &gt;= index; --i) {
				this.children[i] = this.children[i - 1];
			}

			newNode._parentNode = this;
			this.children[index] = newNode;

			if (cgsgExist(this.onChildAdd)) {
                CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_CHILD_ADD, new CGSGEvent(this, {node:this}));
			}
		},

		&#x2F;**
		 * Remove the child passed in parameter and delete it
		 * @method removeChild
		 * @param {CGSGNode} node the nodes to remove
		 * @param {Boolean} searchRecursively if true, search the nodes on all the tree from this nodes
		 * @return {Boolean} true if the child was correctly removed or false if the nodes was not found.
		 * *&#x2F;
		removeChild: function (node, searchRecursively) {
			var index = this.children.indexOf(node);

			if (index &gt;= 0) {
				this.children.without(node);

				if (cgsgExist(this.onChildRemove)) {
                    CGSG.eventManager.dispatch(this, cgsgEventTypes.ON_CHILD_REMOVED, new CGSGEvent(this, {node:this}));
				}
				node.free();

				return true;
			}

			if (searchRecursively) {
				for (var i = 0, len = this.children.length; i &lt; len; ++i) {
					var childNode = this.children[i];
					if (childNode.removeChild(node, true)) {
						return true;
					}
				}
			}

			return false;
		},

		&#x2F;**
		 * remove all children, delete them and reset the current parameters
		 * @method removeAll
		 * *&#x2F;
		removeAll: function () {
			&#x2F;*for (var i = this.children.length; i &gt;=0; --i) {
			 var childNode = this.children[i];
			 childNode.removeAll();
			 this.removeChild(childNode, true);
			 }*&#x2F;

			this.free();
		},

		&#x2F;**
		 * Detach the nodes in index &#x27;index&#x27; without delete it. So it&#x27;s not a child anymore
		 * @method detachChildAt
		 * @param {Number} index
		 *&#x2F;
		detachChildAt: function (index) {
			if (index &gt;= 0 &amp;&amp; index &lt; this.children.length) {
				this.detachChild(this.children[index]);
			}
		},

		&#x2F;**
		 * Detach the nodes without delete it. So it&#x27;s not a child anymore
		 * @method detachChild
		 * @param {CGSGNode} childNode
		 *&#x2F;
		detachChild: function (childNode) {
			if (cgsgExist(childNode)) {
				childNode._parentNode = null;
				&#x2F;*this.children = *&#x2F;
				this.children.without(childNode);
			}
		},

		&#x2F;**
		 * Execute&#x2F;Eval the script passed in parameter in &quot;this&quot; scope.
		 * Used to set new value to an attribute of a node
		 * @method evalSet
		 * @param {String} attribute The attribute to be changed
		 * @param {*} value The new value for the attribute
		 *
		 * @example node.evalSet(&quot;position.y&quot;, 12);
		 *&#x2F;
		evalSet: function (attribute, value) {
			&#x2F;&#x2F;check for common properties to optimize performances
			if (attribute == &quot;position.x&quot;) {
				this.translateTo(value, this.position.y, this.needToKeepAbsoluteMatrix);
			}
			else if (attribute == &quot;position.y&quot;) {
				this.translateTo(this.position.x, value, this.needToKeepAbsoluteMatrix);
			}
			else if (attribute == &quot;dimension.width&quot;) {
				this.resizeTo(value, this.dimension.height);
			}
			else if (attribute == &quot;dimension.height&quot;) {
				this.resizeTo(this.dimension.width, value);
			}
			else if (attribute == &quot;scale.x&quot;) {
				this.scaleTo(value, this.scale.y, this.needToKeepAbsoluteMatrix);
			}
			else if (attribute == &quot;scale.y&quot;) {
				this.scaleTo(this.scale.x, value, this.needToKeepAbsoluteMatrix);
			}
			else if (attribute == &quot;rotation&quot; || attribute == &quot;rotation.angle&quot;) {
				this.rotateTo(value, this.needToKeepAbsoluteMatrix);
			}
			else if (attribute == &quot;globalAlpha&quot;) {
				this.globalAlpha = value;
                this.invalidate();
			}
			else if (attribute == &quot;isVisible&quot;) {
				this.isVisible = value;
			}
			else if (attribute == &quot;rotationCenter.x&quot;) {
				this.rotationCenter.x = value;
			}
			else if (attribute == &quot;rotationCenter.y&quot;) {
				this.rotationCenter.y = value;
			}
			else if (attribute == &quot;color.r&quot;) {
				var rgb = CGSGColor.hex2rgb(this.color);
				this.color = CGSGColor.rgb2hex(value, rgb.g, rgb.b);
                this.invalidate();
			}
			else if (attribute == &quot;color.g&quot;) {
				var rgb = CGSGColor.hex2rgb(this.color);
				this.color = CGSGColor.rgb2hex(rgb.r, value, rgb.b);
                this.invalidate();
			}
			else if (attribute == &quot;color.b&quot;) {
				var rgb = CGSGColor.hex2rgb(this.color);
				this.color = CGSGColor.rgb2hex(rgb.r, rgb.g, value);
                this.invalidate();
			}

			&#x2F;&#x2F;generic property
			else {
				eval(&quot;this.&quot; + attribute + &quot;=&quot; + value);
                this.invalidate();
			}

			&#x2F;*if (this.needToKeepAbsoluteMatrix) {
			 if (attribute.indexOf(&quot;position&quot;) == 0) {
			 this._absolutePosition = this.getAbsolutePosition(true);
			 }
			 else if (attribute.indexOf(&quot;rotation&quot;) == 0) {
			 this._absoluteRotation = this.getAbsoluteRotation(true);
			 }
			 else if (attribute.indexOf(&quot;scale&quot;) == 0) {
			 this._absoluteScale = this.getAbsoluteScale(true);
			 }
			 }*&#x2F;
		},

		&#x2F;**
		 * Set the region inside which one this node ca be placed an can move
		 * @public
		 * @method setRegionConstraint
		 * @param {CGSGRegion} region a CGSGRegion relatively to this parent region. Can be null.
		 *&#x2F;
		setRegionConstraint: function (region) {
			this.regionConstraint = region;
		},

		&#x2F;**
		 * @public
		 * @method getAbsolutePosition
         * @param {boolean} recursive flag indicating if computation should be recusive or not
		 * @return {CGSGPosition} the absolute positions of this node
		 *&#x2F;
		getAbsolutePosition: function (recursive) {
			var n = this;
			var translation = this.position.copy();
			while (n._parentNode !== null) {
				translation.multiplyEquals(n._parentNode.scale);
				n = n._parentNode;
			}

			if (this._parentNode !== null) {
				translation.addEquals(this._parentNode.getAbsolutePosition(false));
			}

            if (recursive !== false) {
                for (var c = 0; c &lt; this.children.length; c++) {
                    if (cgsgExist(this.children[c])) {
                        this.children[c]._absolutePosition = this.children[c].getAbsolutePosition(recursive);
                    }
                }
            }

			return translation;
		},

		&#x2F;**
		 * @public
		 * @method getAbsoluteScale
         * @param {boolean} recursive flag indicating if computation should be recusive or not
		 * @return {CGSGScale} the absolute scale of this node
		 *&#x2F;
		getAbsoluteScale: function (recursive) {
			var n = this;
			var s = this.scale.copy();
			while (n._parentNode !== null) {
				s.multiplyEquals(n._parentNode.scale);
				n = n._parentNode;
			}

            if (recursive !== false) {
                for (var c = 0; c &lt; this.children.length; c++) {
                    if (cgsgExist(this.children[c])) {
                        this.children[c]._absoluteScale = this.children[c].getAbsoluteScale(recursive);
                    }
                }
            }
			return s;
		},

		&#x2F;**
		 * @public
		 * @method getAbsoluteRotation
         * @param {boolean} recursive flag indicating if computation should be recusive or not
         * @return {CGSGRotation} the absolute rotation of this node
		 *&#x2F;
		getAbsoluteRotation: function (recursive) {
			var n = this;
			var r = this.rotation.copy();
			while (n._parentNode !== null) {
				r.addEquals(n._parentNode.rotation.angle);
				n = n._parentNode;
			}

            if (recursive !== false) {
                for (var c = 0; c &lt; this.children.length; c++) {
                    if (cgsgExist(this.children[c])) {
                        this.children[c]._absoluteRotation = this.children[c].getAbsoluteRotation(recursive);
                    }
                }
            }

			return r;
		},

		&#x2F;**
		 * Compute the absolute position, rotation and scale in the canvas container
		 * @public
		 * @method computeAbsoluteMatrix
		 * @param {Boolean} recursive if !== false, compute recursively
		 * *&#x2F;
		computeAbsoluteMatrix: function (recursive) {
			this._absolutePosition = this.getAbsolutePosition(false);
			this._absoluteScale = this.getAbsoluteScale(false);
			this._absoluteRotation = this.getAbsoluteRotation(false);

			if (recursive !== false) {
				&#x2F;&#x2F;for (var c = 0; c &lt; this.children.length; c++) {
                cgsgIterate(this.children, (function(i, child) {
                    if (cgsgExist(child)) {
                        child.computeAbsoluteMatrix(recursive);
                    }
                }).bind(this));
				&#x2F;&#x2F;}
			}
		},

        &#x2F;**
         * Returns the x position with the lowest value between this node and its children.
         *
         * @method getMinAbsoluteLeft
         * @return {Number}
         *&#x2F;
        getMinAbsoluteLeft : function () {
            var retval = this._absolutePosition.x;

            if (this.children.length &gt; 0) {
                cgsgIterate(this.children.length, (function(i, child) {
                    if (retval &lt; child._absolutePosition.x) {
                        retval = child._absolutePosition.x;
                    }
                }).bind(this));
            }

            return retval;
        },

        &#x2F;**
         * Returns the right border&#x27;s position with the highest value between this node and its children.
         *
         * @method getMostAbsoluteRight
         * @return {Number}
         *&#x2F;
        getMaxAbsoluteRight : function () {
            var retval = this._absolutePosition.x + (this.getWidth() * this._absoluteScale.x);

            if (this.children.length &gt; 0) {
                cgsgIterate(this.children.length, (function(i, child) {
                    var absRight = this._absolutePosition.x + (this.getWidth() * this._absoluteScale.x);
                    if (retval &lt; absRight) {
                        retval = absRight;
                    }
                }).bind(this));
            }

            return retval;
        },

        &#x2F;**
         * Returns the y position with the lowest value between this node and its children.
         *
         * @method getMinAbsoluteTop
         * @return {Number}
         *&#x2F;
        getMinAbsoluteTop : function () {
            var retval = this._absolutePosition.y;

            if (this.children.length &gt; 0) {
                cgsgIterate(this.children.length, (function(i, child) {
                    if (retval &lt; child._absolutePosition.y) {
                        retval = child._absolutePosition.y;
                    }
                }).bind(this));
            }

            return retval;
        },

        &#x2F;**
         * Returns the bottom border&#x27;s position with the highest value between this node and its children.
         *
         * @method getAbsoluteBottom
         * @return {Number}
         *&#x2F;
        getMaxAbsoluteBottom: function () {
            var retval = this._absolutePosition.y + (this.getHeight() * this._absoluteScale.y);

            if (this.children.length &gt; 0) {
                cgsgIterate(this.children.length, (function(i, child) {
                    var absRight = this._absolutePosition.y + (this.getHeight() * this._absoluteScale.y);
                    if (retval &lt; absRight) {
                        retval = absRight;
                    }
                }).bind(this));
            }

            return retval;
        },
		&#x2F;**
         *
		 * @method getAbsoluteLeft
		 * @return {Number}
		 *&#x2F;
		getAbsoluteLeft  : function () {
			return this._absolutePosition.x;
		},

		&#x2F;**
		 * @method getAbsoluteRight
		 * @return {Number}
		 *&#x2F;
		getAbsoluteRight : function () {
			return this._absolutePosition.x + this.getAbsoluteWidth();
		},

		&#x2F;**
		 * @method getAbsoluteTop
		 * @return {Number}
		 *&#x2F;
		getAbsoluteTop   : function () {
			return this._absolutePosition.y;
		},

		&#x2F;**
		 * @method getAbsoluteBottom
		 * @return {Number}
		 *&#x2F;
		getAbsoluteBottom: function () {
			return this._absolutePosition.y + this.getAbsoluteHeight();
		},

		&#x2F;**
		 * @method getAbsoluteWidth
		 * @return {Number}
		 *&#x2F;
		getAbsoluteWidth : function () {
			return this.getWidth() * this._absoluteScale.x;
		},

		&#x2F;**
		 * @method getAbsoluteHeight
		 * @return {Number}
		 *&#x2F;
		getAbsoluteHeight: function () {
			return this.getHeight() * this._absoluteScale.y;
		},

		&#x2F;**
		 * @method getWidth
		 * @return {Number}
		 *&#x2F;
		getWidth : function () {
			return this.dimension.width;
		},

		&#x2F;**
		 * @method getHeight
		 * @return {Number}
		 *&#x2F;
		getHeight  : function () {
			return this.dimension.height;
		},

		&#x2F;**
         * Test if this node is colliding the node in parameter. Don&#x27;t forget to add nodes to CGSGCollisionManager.
         *
		 * @public
		 * @method isColliding
		 * @return {Boolean} true if the 2 nodes are colliding. They are colliding if the distance between them is minus than the threshold parameter
		 * @param {CGSGNode} node a CGSGNode
		 * @param {Number} threshold space between the 2 nodes before considering they are colliding
		 *&#x2F;
		isColliding: function (node, threshold) {
            return CGSG.collisionManager.isColliding(this, node, threshold);
		},

		&#x2F;**
		 * @public
		 * @method getListOfCollidingBrothers
		 * @return {Array} a Array of nodes this one is colliding with (can be empty)
		 * @param {Number} threshold space between the 2 nodes before considering they are colliding
		 *&#x2F;
		getListOfCollidingBrothers: function (threshold) {
			var listOfCollidingNodes = [];
			var brother = null;
			&#x2F;&#x2F;for (var n = 0; n &lt; this._parentNode.children.length; n++) {
            cgsgIterate(this._parentNode.children, (function(i, brother) {
				if (brother !== this &amp;&amp; this.isColliding(brother, threshold)) {
					listOfCollidingNodes.push(brother);
				}
            }).bind(this));
			&#x2F;&#x2F;}

			return listOfCollidingNodes;
		},

		&#x2F;**
		 * @public
		 * @method isCollidingABrother
		 * @param {Number} threshold space between the 2 nodes before considering they are colliding
		 * @return {Boolean} true if this node is colliding one of the other children of its parent node
		 *&#x2F;
		isCollidingABrother: function (threshold) {
            var retval = false;

            cgsgIterate(this._parentNode.children, (function(i, brother) {
				if (brother !== this &amp;&amp; this.isColliding(brother, threshold)) {
					retval = true;

                    return retval; &#x2F;&#x2F; break the loop
				}
            }).bind(this));

			return retval;
		},

		&#x2F;*
		 * TODO : to be completed
		 * Return the list of lines going joigning nodes&#x27; peaks
		 * param onlyBrothers a Boolean. Default = true
		 * param threshold distance from which the detectection is done
		 * return an array of CGSGVector2D (can be empty)
		 *&#x2F;
		&#x2F;*getMagneticLines : function(onlyBrothers, threshold) {
		 if (!cgsgExist(onlyBrothers)) {
		 onlyBrothers = true;
		 }

		 &#x2F;&#x2F;compute vectors
		 var topVector = this.getAbsoluteTop();
		 var bottomVector = this.getAbsoluteBottom();
		 var leftVector = this.getAbsoluteLeft();
		 var rightVector = this.getAbsoluteRight();

		 &#x2F;&#x2F;line = a point and a normalized CGSGVector2D (ie : [0, 1] or [1, 0])
		 var listOfLines = [];

		 var brother = null;
		 for (var n = 0; n &lt; this._parentNode.children.length; n++) {
		 brother = this._parentNode.children[n];

		 &#x2F;&#x2F;vectors v &amp; v&#x27; are colinear if and only if xy’ - yx’ = 0.

		 }

		 return listOfLines;
		 },*&#x2F;

		&#x2F;**
		 * Must be overrided by inherited classes
		 * @method copy
		 * @param {CGSGNode} node
		 * @return {CGSGNode} a copy of this node
		 *&#x2F;
		copy: function (node) {
			if (node === null || node === undefined) {
				node = new CGSGNode(this.position.x, this.position.y);
                node.resizeTo(this.dimension.width, this.dimension.height);
			}
			node.classType = this.classType;
			node.name = this.name;
			node.globalAlpha = this.globalAlpha;
			node.isVisible = this.isVisible;
			node.isProportionalResize = this.isProportionalResize;
			node.pickNodeMethod = this.pickNodeMethod;
			node.needToKeepAbsoluteMatrix = this.needToKeepAbsoluteMatrix;

			&#x2F;&#x2F;list of the children (empty if this nodes is a leaf)
			&#x2F;&#x2F;this.children = [];

			if (this.regionConstraint !== null) {
				node.regionConstraint = this.regionConstraint.copy();
			}

			&#x2F;&#x2F;can be fulfilled by the developer to put in whatever he needs
			if (this.userdata !== null) {
				node.userdata = this.userdata.copy();
			}

			&#x2F;&#x2F;selection attributes
			&#x2F;&#x2F;if true, this nodes is clickable and so will be checked by the pickNode function
			node.isClickable = this.isClickable;
			&#x2F;&#x2F;if true, this nodes can be selected and so can be transformed (dimension)
			node.isResizable = this.isResizable;
			node.isDraggable = this.isDraggable;
			node.isTraversable = this.isTraversable;

			node.selectionLineColor = this.selectionLineColor;
			node.selectionLineWidth = this.selectionLineWidth;
			node.selectionHandleSize = this.selectionHandleSize;
			node.selectionHandleColor = this.selectionHandleColor;
			node._id = this._id;
			node.translateTo(this.position.x, this.position.y);
			node.resizeTo(this.dimension.width, this.dimension.height);
			node.scaleTo(this.scale.x, this.scale.y);
			node.rotateTo(this.rotation.angle);

			node.selectableZone =
			new CGSGRegion(node.position.x, node.position.y, node.dimension.width, node.dimension.height);

			&#x2F;&#x2F;all the events for the node
			node.onMouseOver = this.onMouseOver;
			node.onMouseOut = this.onMouseOut;
			node.onClick = this.onClick;
			node.onDblClick = this.onDblClick;
			node.onDrag = this.onDrag;
			node.onDragEnd = this.onDragEnd;
			node.onResize = this.onResize;
			node.onResizeEnd = this.onResizeEnd;
			node.onSelect = this.onSelect;
			node.onDeselect = this.onDeselect;

			node.computeAbsoluteMatrix(true);

			return node;
		},

		&#x2F;**
		 * free memory taken by this object and it&#x27;s children.
		 * The &#x27;userData&#x27; property won&#x27;t be freed
		 * @method free
		 *&#x2F;
		free: function () {
			for (var c = this.children.length - 1; c &gt;= 0; c--) {
				this.children[c].free();
			}

			this.children.clear();

			cgsgFree(this);
		}
	}
);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
