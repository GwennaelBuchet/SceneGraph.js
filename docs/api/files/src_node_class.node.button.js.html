<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\node\class.node.button.js - cgSceneGraph</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/__GLOBAL_CONSTANTS__.html">__GLOBAL_CONSTANTS__</a></li>
            
                <li><a href="..&#x2F;classes/__GLOBAL_METHODS__.html">__GLOBAL_METHODS__</a></li>
            
                <li><a href="..&#x2F;classes/__GLOBAL_PROPERTIES__.html">__GLOBAL_PROPERTIES__</a></li>
            
                <li><a href="..&#x2F;classes/__UTIL_ARRAY__.html">__UTIL_ARRAY__</a></li>
            
                <li><a href="..&#x2F;classes/CGSGAnimationKey.html">CGSGAnimationKey</a></li>
            
                <li><a href="..&#x2F;classes/CGSGButtonMode.html">CGSGButtonMode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGColor.html">CGSGColor</a></li>
            
                <li><a href="..&#x2F;classes/CGSGDimension.html">CGSGDimension</a></li>
            
                <li><a href="..&#x2F;classes/CGSGHandleBox.html">CGSGHandleBox</a></li>
            
                <li><a href="..&#x2F;classes/CGSGMath.html">CGSGMath</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNode.html">CGSGNode</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeButton.html">CGSGNodeButton</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeCircle.html">CGSGNodeCircle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeEllipse.html">CGSGNodeEllipse</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeImage.html">CGSGNodeImage</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSprite.html">CGSGNodeSprite</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeSquare.html">CGSGNodeSquare</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeText.html">CGSGNodeText</a></li>
            
                <li><a href="..&#x2F;classes/CGSGNodeWebview.html">CGSGNodeWebview</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticle.html">CGSGParticle</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleEmitter.html">CGSGParticleEmitter</a></li>
            
                <li><a href="..&#x2F;classes/CGSGParticleSystem.html">CGSGParticleSystem</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPickNodeMethod.html">CGSGPickNodeMethod</a></li>
            
                <li><a href="..&#x2F;classes/CGSGPosition.html">CGSGPosition</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRegion.html">CGSGRegion</a></li>
            
                <li><a href="..&#x2F;classes/CGSGRotation.html">CGSGRotation</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScale.html">CGSGScale</a></li>
            
                <li><a href="..&#x2F;classes/CGSGScene.html">CGSGScene</a></li>
            
                <li><a href="..&#x2F;classes/CGSGSceneGraph.html">CGSGSceneGraph</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTimeline.html">CGSGTimeline</a></li>
            
                <li><a href="..&#x2F;classes/CGSGTraverser.html">CGSGTraverser</a></li>
            
                <li><a href="..&#x2F;classes/CGSGVector2D.html">CGSGVector2D</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWEBVIEWMODE.html">CGSGWEBVIEWMODE</a></li>
            
                <li><a href="..&#x2F;classes/CGSGWrapMode.html">CGSGWrapMode</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Animation.html">Animation</a></li>
            
                <li><a href="..&#x2F;modules/Math.html">Math</a></li>
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/ParticleSystem.html">ParticleSystem</a></li>
            
                <li><a href="..&#x2F;modules/Scene.html">Scene</a></li>
            
                <li><a href="..&#x2F;modules/Util.html">Util</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\node\class.node.button.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2012  Capgemini Technology Services (hereinafter “Capgemini”)
 *
 * License&#x2F;Terms of Use
 *
 * Permission is hereby granted, free of charge and for the term of intellectual property rights on the Software, to any
 * person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to use, copy, modify
 * and propagate free of charge, anywhere in the world, all or part of the Software subject to the following mandatory conditions:
 *
 *   •    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 *  Any failure to comply with the above shall automatically terminate the license and be construed as a breach of these
 *  Terms of Use causing significant harm to Capgemini.
 *
 *  THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
 *  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *  Except as contained in this notice, the name of Capgemini shall not be used in advertising or otherwise to promote
 *  the use or other dealings in this Software without prior written authorization from Capgemini.
 *
 *  These Terms of Use are subject to French law.
 *&#x2F;

&#x2F;**
 * List the modes for a button : NORMAL, OVER, DEACTIVATED.
 * @class CGSGButtonMode
 * @type {Object}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 * @example
 *      myTextNode.setWrapMode(CGSGWrapMode.WORD, true);
 *&#x2F;
var CGSGButtonMode = {
    &#x2F;**
     * @property NORMAL
     *&#x2F;
    NORMAL:{index:0, isClickable:true},
    &#x2F;**
     * @property OVER
     *&#x2F;
    OVER:{index:1, isClickable:true},
    &#x2F;**
     * @property DEACTIVATED
     *&#x2F;
    DEACTIVATED:{index:2, isClickable:false}
};


var CGSGPositionMode = {
    &#x2F;**
     * @property TOP
     *&#x2F;
    TOP:{index:0, decalX:0, decalY:-1, dt:1, dy:1,
        computeWidth:function (item1, item2) {
            return Math.max(item1, item2);
        },
        computeHeight:function (item1, item2) {
            return 0;
        }},

    &#x2F;**
     * @property BOTTOM
     *&#x2F;
    BOTTOM:{index:1, decalX:0, decalY:1, dt:0, dy:1,
        computeWidth:function (item1, item2) {
            return Math.max(item1, item2);
        },
        computeHeight:function (item1, item2) {
            return 0;
        }},
    &#x2F;**
     * @property LEFT
     *&#x2F;
    LEFT:{index:2, decalX:-1, decalY:0, dt:0, dy:0,
        computeWidth:function (item1, item2) {
            return 0;
        },
        computeHeight:function (item1, item2) {
            return Math.max(item1, item2);
        }},
    &#x2F;**
     * @property RIGHT
     *&#x2F;
    RIGHT:{index:3, decalX:1, decalY:0, dt:1, dy:0,
        computeWidth:function (item1, item2) {
            return 0;
        },
        computeHeight:function (item1, item2) {
            return Math.max(item1, item2);
        }}
};


&#x2F;**
 * A CGSGNodeButton represent a basic square
 *
 * @class CGSGNodeButton
 * @module Node
 * @extends CGSGNode
 * @constructor
 * @param {Number} x Relative position on X
 * @param {Number} y Relative position on X
 * @param {Number} width Relative dimension
 * @param {Number} height Relative Dimension
 * @param {Number} radius Radius for the round corner
 * @type {CGSGNodeButton}
 * @author Gwennael Buchet (gwennael.buchet@capgemini.com)
 *&#x2F;
var CGSGNodeButton = CGSGNode.extend(
    {
        initialize:function (x, y, text) {
            this._super(x, y, 0, 0);

            &#x2F;**
             * High colors for the button in 3 mode : normal, over, deactivated
             * @property _firstColors
             * @default [&quot;#858585&quot;, &quot;#5F5F5F&quot;, &quot;#9C9C9C&quot;]
             * @type {Array}
             * @private
             *&#x2F;
            this._firstColors = [&quot;#969696&quot;, &quot;#5F5F5F&quot;, &quot;#D8D8D8&quot;];
            &#x2F;**
             * Low color for the button in 3 mode : normal, over, deactivated
             * @property _lastColors
             * @default [&quot;#606060&quot;, &quot;#4B4B4B&quot;, &quot;#747474&quot;]
             * @type {Array}
             * @private
             *&#x2F;
            this._lastColors = [&quot;#7F7F7F&quot;, &quot;#4B4B4B&quot;, &quot;#B5B5B5&quot;];

            &#x2F;**
             * Shadow color for the button in 3 mode : normal, over, deactivated. Can be null.
             * @property _shadowColors
             * @default [null, null, null]
             * @type {Array}
             * @private
             *&#x2F;
            this._shadowColors = [null, null, null];

            &#x2F;**
             * Radius for the round corner in 3 mode : normal, over, deactivated
             * @property _radiuses
             * @type {Array}
             * @default [10, 10, 10]
             * @private
             *&#x2F;
            this._radiuses = [8, 8, 8];

            &#x2F;**
             * Text for the button in 3 mode : normal, over, deactivated
             * @property _texts
             * @default [text, text, text]
             * @type {Array}
             * @private
             *&#x2F;
            this._texts = [text, text, text];

            &#x2F;**
             * Text size for the button in 3 mode : normal, over, deactivated
             * @property _textSizes
             * @default [12, 12, 12]
             * @type {Array}
             * @private
             *&#x2F;
            this._textSizes = [12, 12, 12];

            &#x2F;**
             * Color for the text in the 3 mode  : normal, over, deactivated
             * @property _textColors
             * @type {Array}
             * @default [&quot;white&quot;, &quot;white&quot;, &quot;gray&quot;]
             * @private
             *&#x2F;
            this._textColors = [&quot;white&quot;, &quot;white&quot;, &quot;#999999&quot;];

            &#x2F;**
             * Text Node encapsulating the text rendering
             * @property _textsNode
             * @type {CGSGNodeText}
             *&#x2F;
            this.textNode = new CGSGNodeText(0, 0, &quot;&quot;);
            this.textNode.setTextAlign(&quot;center&quot;, false);
            this.textNode.setTextBaseline(&quot;middle&quot;, false);

            this._strokeColor = null;
            this._lineWidth = 2;

            &#x2F;**
             * @property _picto
             * @type {CGSGNodeImage}
             *&#x2F;
            this._picto = new CGSGNodeImage(0, 0, null);
            &#x2F;**
             * @property _slices
             * @type {Array}
             *&#x2F;
            this._slices = [];

            &#x2F;**
             * @property _pictoPosition
             * @default CGSGPositionMode.LEFT
             * @type {CGSGPositionMode}
             * @private
             *&#x2F;
            this._pictoPosition = CGSGPositionMode.LEFT;

            &#x2F;**
             * Distance between the picto and the text
             * @property _distancePictoText
             * @default 10
             * @type {Number}
             * @private
             *&#x2F;
            this._distancePictoText = 10;

            &#x2F;**
             * Fake canvases to pre-render static display
             * @property _tmpCanvas
             * @type {Array}
             * @private
             *&#x2F;
            this._tmpCanvas =
                [document.createElement(&#x27;canvas&#x27;), document.createElement(&#x27;canvas&#x27;), document.createElement(&#x27;canvas&#x27;)];

            &#x2F;**
             * Padding applied to the left and right of the text
             * @property _horizontalPadding
             * @type {Number}
             * @default 15
             * @private
             *&#x2F;
            this._horizontalPadding = 15;
            &#x2F;**
             * Padding applied to the top and bottom of the text
             * @property _verticalPadding
             * @type {Number}
             * @default 10
             * @private
             *&#x2F;
            this._verticalPadding = 10;

            &#x2F;**
             * Computed dimensions of the button in the 3 modes.
             * Do not edit manually!
             * @property _dimensions
             * @type {Array}
             * @private
             *&#x2F;
            this._dimensions = [];

            &#x2F;**
             * @property classType
             * @readonly
             * @type {String}
             * @default &quot;CGSGNodeButton&quot;
             *&#x2F;
            this.classType = &quot;CGSGNodeButton&quot;;

            this._initShapes();

            &#x2F;**
             * Current mode of the button
             * @property _currentMode
             * @type {CGSGButtonMode}
             * @default CGSGButtonMode.NORMAL
             * @private
             *&#x2F;
            this._currentMode = CGSGButtonMode.NORMAL;

            this.setMode(CGSGButtonMode.NORMAL);

            var that = this;
            this.onMouseOver = function (event) {
                if (that.getMode() == CGSGButtonMode.NORMAL) {
                    that.setMode(CGSGButtonMode.OVER);
                }
            };

            this.onMouseOut = function (event) {
                if (that.getMode() == CGSGButtonMode.OVER) {
                    that.setMode(CGSGButtonMode.NORMAL);
                }
            };
        },

        &#x2F;**
         * Change the position of the picto : CGSGPositionMode.LEFT, CGSGPositionMode.TOP, CGSGPositionMode.RIGHT, CGSGPositionMode.BOTTOM
         * @method setPictoPosition
         * @param {CGSGPositionMode} p
         *&#x2F;
        setPictoPosition:function (p) {
            this._pictoPosition = p;
            this._needRedraw = true;
        },

        &#x2F;**
         * Set the image for the picto
         * @method setImage
         * @param {Image} img
         *&#x2F;
        setImage:function (img) {
            this._picto.setImage(img);
            this._needRedraw = true;
        },

        &#x2F;**
         * Set the URL for the picto
         * @method setImageURL
         * @param url
         *&#x2F;
        setImageURL:function (url) {
            this._picto.onLoadEnd = this._onLoadImageEnd.bind(this);
            this._picto.setURL(url);
        },

        _onLoadImageEnd:function () {
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the slices in the image for the 3 modes
         * @method getSlices
         * @return {Array}
         *&#x2F;
        getSlices:function () {
            return this._slices;
        },
        &#x2F;**
         * Set the slices in the image for the 3 modes
         * @method setSlices
         * @param {Array} values
         *&#x2F;
        setSlices:function (values) {
            this._slices = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the High color for the button
         * @method getFirstColor
         * @return {Array}
         *&#x2F;
        getFirstColors:function () {
            return this._firstColors;
        },
        &#x2F;**
         * Set the values for the high color of the button
         * @method setFirstColor
         * @param values {Array}
         *&#x2F;
        setFirstColors:function (values) {
            this._firstColors = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the Low color for the button
         * @method getLastColor
         * @return {Array}
         *&#x2F;
        getLastColors:function () {
            return this._lastColors;
        },
        &#x2F;**
         * Set the values for the low color of the button
         * @method setLastColor
         * @param values {Array}
         *&#x2F;
        setLastColors:function (values) {
            this._lastColors = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the Shadow color for the button
         * @method getShadowColor
         * @return {Array}
         *&#x2F;
        getShadowColors:function () {
            return this._shadowColors;
        },
        &#x2F;**
         * Set the values for the shadow color of the button
         * @method setShadowColor
         * @param values {Array}
         *&#x2F;
        setShadowColors:function (values) {
            this._shadowColors = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the Low color for the button
         * @method getRadius
         * @return {Array}
         *&#x2F;
        getRadiuses:function () {
            return this._radiuses;
        },
        &#x2F;**
         * Set the values for the low color of the button
         * @method setRadius
         * @param values {Array}
         *&#x2F;
        setRadiuses:function (values) {
            this._radiuses = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the text of the button
         * @method getText
         * @return {Array}
         *&#x2F;
        getTexts:function () {
            return this._texts;
        },
        &#x2F;**
         * Set the values for text of the button
         * @method setText
         * @param valuess {Array}
         * @example
         *  button.setText([&quot;normal&quot;, &quot;over&quot;, &quot;deactivated&quot;]);
         *&#x2F;
        setTexts:function (valuess) {
            &#x2F;&#x2F;if valuess is not an array, create an array of 3 times this values
            if (!cgsgIsArray(valuess)) {
                var v = valuess.toString();
                valuess = [v, v, v];
            }

            this._texts = valuess;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the text sizes of the button
         * @method getTextSize
         * @return {Array}
         *&#x2F;
        getTextSizes:function () {
            return this._textSizes;
        },
        &#x2F;**
         * Set the values for text sizes of the button
         * @method setTextSize
         * @param values {Array}
         *&#x2F;
        setTextSizes:function (values) {
            this._textSizes = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the text of the button
         * @method getTextColor
         * @return {Array}
         *&#x2F;
        getTextColors:function () {
            return this._textColors;
        },
        &#x2F;**
         * Set the color for text of the button
         * @method setTextColor
         * @param values {Array}
         * @example
         *  button.setTextColor([&quot;white&quot;, &quot;green&quot;, &quot;yellow&quot;]);
         *&#x2F;
        setTextColors:function (values) {
            this._textColors = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the horizontal padding of the button
         * @method getHorizontalPadding
         * @return {Number}
         *&#x2F;
        getHorizontalPadding:function () {
            return this._horizontalPadding;
        },
        &#x2F;**
         * Set the horizontal padding of the button
         * @method setHorizontalPadding
         * @param values {Number}
         *&#x2F;
        setHorizontalPadding:function (values) {
            this._horizontalPadding = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * Return the vertical padding of the button
         * @method getVerticalPadding
         * @return {Number}
         *&#x2F;
        getVerticalPadding:function () {
            return this._verticalPadding;
        },
        &#x2F;**
         * Set the vertical padding of the button
         * @method setHorizontalPadding
         * @param values {Number}
         *&#x2F;
        setVerticalPadding:function (values) {
            this._verticalPadding = values;
            this._needRedraw = true;
        },

        &#x2F;**
         * @method setFixedSize
         * @param {CGSGDimension} dim Can be null to remove fixed size
         *&#x2F;
        setFixedSize:function (dim) {
            this._dimensions[0] = dim;
            this._dimensions[1] = dim;
            this._dimensions[2] = dim;
            this._fixedSize = cgsgExist(dim);
            this._needRedraw = true;
        },

        &#x2F;**
         * Pre-render the button into a temp canvas to optimize the perfs
         * @method _initShape
         * @private
         *&#x2F;
        _initShapes:function () {
            this._initShape(0);
            this._initShape(1);
            this._initShape(2);
            this._needRedraw = false;
        },

        &#x2F;**
         * Pre-render the shape for normal rendering
         * @method _initShape
         * @param {Number} index
         * @private
         *&#x2F;
        _initShape:function (index) {
            this.textNode.setSize(this._textSizes[index], false);
            this.textNode.setText(this._texts[index], true);

            var dPT = this._distancePictoText;
            if (this._texts[index] === &quot;&quot;){
                dPT = 0;
            }

            var decalPictoX = 0, decalPictoY = 0;
            var wImg = 0;
            var hImg = 0;
            if (this._picto.isLoaded) {
                if (this._slices.length &gt; 0) {
                    this._picto.setSlice(this._slices[index].position.x, this._slices[index].position.y,
                        this._slices[index].dimension.width, this._slices[index].dimension.height, true);
                }

                wImg = this._picto.slice.dimension.width;
                hImg = this._picto.slice.dimension.height;

                decalPictoX = (wImg + dPT) * Math.abs(this._pictoPosition.decalX);
                decalPictoY = (hImg + dPT) * Math.abs(this._pictoPosition.decalY);
            }

            if (this._fixedSize) {
                this.resizeTo(this._dimensions[index].width, this._dimensions[index].height);
            }
            else {
                this.resizeTo(
                    (2 * this._horizontalPadding) + decalPictoX + this.textNode.getWidth() * Math.abs(this._pictoPosition.decalX) +
                        this._pictoPosition.computeWidth(this.textNode.getWidth(), wImg),
                    (2 * this._verticalPadding) + decalPictoY + this.textNode.getHeight() * Math.abs(this._pictoPosition.decalY) +
                        this._pictoPosition.computeHeight(this.textNode.getHeight(), hImg));

                this._dimensions[index] = this.dimension.copy();
            }



            this._tmpCanvas[index].width = this.dimension.width + 2 * this._radiuses[index];
            this._tmpCanvas[index].height = this.dimension.height + 2 * this._radiuses[index];
            var tmpContext = this._tmpCanvas[index].getContext(&#x27;2d&#x27;);

            cgsgClearContext(tmpContext);

            &#x2F;&#x2F;render the panel
            tmpContext.save();
            {
                var r = this._radiuses[index];
                tmpContext.translate(-r, -r);
                tmpContext.beginPath();

                tmpContext.moveTo(r, r);
                tmpContext.lineTo(r + this.dimension.width - r, r);
                tmpContext.quadraticCurveTo(r + this.dimension.width,
                    r,
                    r + this.dimension.width,
                    r + r);
                tmpContext.lineTo(r + this.dimension.width,
                    r + this.dimension.height - r);
                tmpContext.quadraticCurveTo(r + this.dimension.width,
                    r + this.dimension.height,
                    r + this.dimension.width - r,
                    r + this.dimension.height);
                tmpContext.lineTo(r + r,
                    r + this.dimension.height);
                tmpContext.quadraticCurveTo(r,
                    r + this.dimension.height,
                    r,
                    r + this.dimension.height - r);
                tmpContext.lineTo(r, r + r);
                tmpContext.quadraticCurveTo(r, r,
                    r + r,
                    r);
                tmpContext.closePath();

                var gradient = tmpContext.createLinearGradient(0, 0, 0, this.dimension.height);
                gradient.addColorStop(0, this._firstColors[index]);
                gradient.addColorStop(1, this._lastColors[index]);
                tmpContext.fillStyle = gradient;

                if (cgsgExist(this._shadowColors)) {
                    tmpContext.shadowColor = this._shadowColors[index];
                    tmpContext.shadowBlur = 10;
                    tmpContext.shadowOffsetX = 0;
                    tmpContext.shadowOffsetY = 0;
                }

                tmpContext.fill();

                if (cgsgExist(this._strokeColor)) {
                    tmpContext.strokeStyle = this._strokeColor;
                    tmpContext.lineWidth = this._lineWidth;
                    tmpContext.stroke();
                }
            }
            tmpContext.restore();

            this.textNode.color = this._textColors[index];

            var w = this.textNode.getWidth();
            var h = this.textNode.getHeight() - this.textNode._size;

            var textX = (-this._pictoPosition.decalX * decalPictoX + this.getWidth() - w) &#x2F; 2;
            var textY = (-this._pictoPosition.decalY * decalPictoY + this.getHeight() - h) &#x2F; 2;
            &#x2F;&#x2F;(this.getHeight() - (this.textNode.getHeight() - this.textNode._size)) &#x2F; 2;

            if (this._picto.isLoaded) {
                var ctX = w &#x2F; 2;
                var ctY = h &#x2F; 2;

                this._picto.translateTo(
                    textX + ctX + this._pictoPosition.decalX * (ctX + dPT + (1 - this._pictoPosition.dt) * wImg) - this._pictoPosition.dy * wImg &#x2F; 2,
                    &#x2F;&#x2F;textY + (h - hImg) &#x2F; 2
                    (1 - this._pictoPosition.dy) * (textY + (h - hImg) &#x2F; 2)
                        + this._pictoPosition.dy * (textY - this.textNode._size &#x2F; 2
                        - this._pictoPosition.dt * (dPT + hImg) + (1 - this._pictoPosition.dt) * (this.textNode.getHeight() + dPT))
                    &#x2F;&#x2F;+ this._pictoPosition.dy * (textY - this.textNode._size &#x2F; 2 - ( this._pictoPosition.dt) * this.textNode.getHeight())
                );

                this._picto.render(tmpContext);
            }

            this.textNode.translateTo(textX, textY);
            this.textNode.render(tmpContext);
        },

        &#x2F;**
         * Switch current mode
         * @method setMode
         * @param {CGSGButtonMode} mode
         *&#x2F;
        setMode:function (mode) {
            this._currentMode = mode;
            this.isClickable = mode.isClickable;
            this.resizeTo(this._dimensions[mode.index].width, this._dimensions[mode.index].height);
        },

        &#x2F;**
         * @method getMode
         * @return {CGSGButtonMode}
         *&#x2F;
        getMode:function () {
            return this._currentMode;
        },

        &#x2F;**
         * Custom rendering
         * @method render
         * @protected
         * @override
         * @param {CanvasRenderingContext2D} context the context into render the node
         * *&#x2F;
        render:function (context) {
            &#x2F;&#x2F;save current state
            this.beforeRender(context);

            context.globalAlpha = this.globalAlpha;

            if (this._needRedraw) {
                this._initShapes();
            }
            &#x2F;&#x2F;render the pre-rendered canvas
            context.drawImage(this._tmpCanvas[this._currentMode.index], 0, 0);

            &#x2F;&#x2F;restore state
            this.afterRender(context);
        },

        &#x2F;**
         * @method copy
         * @return {CGSGNodeSquare} a copy of this node
         *&#x2F;
        copy:function () {
            var node = new CGSGNodeSquare(this.position.x, this.position.y, this.dimension.width,
                this.dimension.height);
            &#x2F;&#x2F;call the super method
            node = this._super(node);

            node.color = this.color;
            node.lineColor = this.lineColor;
            node.lineWidth = this.lineWidth;
            return node;
        }
    }
);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
